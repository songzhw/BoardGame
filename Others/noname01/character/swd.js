"use strict";
character.swd = {
  character: {
    swd_huzhongxian: ["male", "wu", 3, ["daofa", "xielv", "xiangu"], ["fullskin"]],

    swd_anka: ["male", "qun", 3, ["songci", "anlianying"], ["fullskin"]],
    swd_septem: ["male", "qun", 4, ["jiying", "liaoyuan", "yishan"], ["fullskin"]],
    swd_kama: ["female", "qun", 3, ["yueren", "shangshi"], ["fullskin"]],
    swd_miles: ["male", "qun", 4, ["aojian", "miles_xueyi", "mohua2"]],
    swd_nicole: ["female", "wu", 3, ["minjing", "lingwu", "huanjian"], ["fullskin"]],
    swd_wangsiyue: ["female", "wei", 3, ["duishi", "guisi", "biyue"]],
    swd_weida: ["female", "qun", 3, ["yueren", "zhenlie"]],
    swd_xuanyuanjianxian: ["male", "qun", 4, ["fengmo", "pozhou", "huajian"], ["fullskin"]],

    swd_chenjingchou: ["male", "wu", 3, ["youyin", "yihua"], ["fullskin"]],
    swd_duguningke: ["female", "qun", 3, ["lianji", "touxi"], ["fullskin"]],
    swd_guyue: ["male", "wei", 3, ["tiandao", "swdqinyin", "wangchen"], ["fullskin"]],
    swd_tuobayuer: ["female", "shu", 4, ["liuhong", "poyue", "niepan"], ["fullskin"]],
    swd_yuwentuo: ["male", "qun", 4, ["wushuang", "xielei", "kunlunjing"], ["fullskin"]],
    swd_yuxiaoxue: ["female", "wei", 3, ["huanhun", "daixing", "yinyue"], ["fullskin"]],

    swd_jiliang: ["male", "wu", 3, ["yunchou", "gongxin", "qimou"], ["fullskin"]],
    swd_shuijing: ["female", "qun", 4, ["mojian", "duoren", "duanyue"], ["fullskin"]],
    swd_cheyun: ["female", "wu", 3, ["shengong", "xianjiang3", "qiaoxie"], ["fullskin"]],
    swd_huanyuanzhi: ["male", "qun", 3, ["lanzhi", "mufeng", "tianshu"], ["fullskin"]],
    swd_murongshi: ["female", "shu", 4, ["duanyi", "guxing"], ["fullskin"]],
    swd_jipeng: ["male", "wu", 3, ["reyingzi", "guozao"], ["fullskin"]],
    swd_qi: ["male", "qun", 3, ["yaotong", "heihuo", "pojian"], ["fullskin"]],

    swd_luchengxuan: ["male", "wu", 4, ["ljifeng", "lxianglong"], ["fullskin"]],
    swd_xiarou: ["female", "shu", 3, ["xianghui", "huiqi"], ["fullskin"]],
    swd_moye: ["female", "wu", 3, ["rexue", "liuli"], ["fullskin"]],

    swd_zhaoyun: ["male", "shu", 4, ["ningjian", "pozhen", "tanlin"], ["fullskin"]],
    swd_hengai: ["female", "shu", 3, ["funiao", "ningxian", "lingbo"], ["fullskin"]],
    swd_duanmeng: ["female", "shu", 4, ["jizhan", "lieren"], ["fullskin"]],
    swd_jiangwu: ["male", "shu", 4, ["yijue", "dangping"], ["fullskin"]],
    swd_tuwei: ["male", "shu", 3, ["zhanlu", "susheng"], ["fullskin"]],
    swd_yeyaxi: ["female", "shu", 3, ["rexue", "huopu"], ["fullskin"]],

    swd_muyun: ["male", "wei", 4, ["ningjian", "polang", "jikong"], ["fullskin"]],
    swd_lanyin: ["female", "wei", 3, ["xingdian", "yulin", "luomei"], ["fullskin"]],
    swd_zhiyin: ["female", "wei", 3, ["xuehuang", "ningshuang", "zhuyu"], ["fullskin"]],
    swd_qiner: ["female", "wei", 3, ["huanyin", "tianhuo", "xuanzhou"], ["fullskin"]],
    swd_jiuyou: ["male", "wei", 3, ["lexue"], ["fullskin"]],
    swd_duopeng: ["male", "wu", 3, ["luanji", "reyingzi"], ["fullskin"]],

    swd_fengtianling: ["male", "shu", 4, ["guiyan", "jiang"], ["fullskin"]],
    swd_huyue: ["female", "wu", 3, ["yunshen", "fengming"], ["fullskin"]],
    swd_jialanduo: ["male", "qun", 4, ["xianyin", "mailun"], ["fullskin"]],
    swd_rongshuang: ["female", "wu", 3, ["suiyan", "duanxing"], ["fullskin"]],
    swd_zhuoshanzhu: ["male", "wu", 4, ["suiyan", "wanjun"], ["fullskin"]],
    swd_jiting: ["female", "wei", 4, ["guanhu", "chuanyang"], ["fullskin"]],

    swd_sikongyu: ["male", "wu", 4, ["sliufeng", "linyun", "hutian"], ["fullskin"]],
    swd_muyue: ["female", "wei", 3, ["xingzhui", "lingxian", "shouyin"], ["fullskin"]],
    swd_ziqiao: ["female", "shu", 3, ["guaili", "pingshen", "fuyan"], ["fullskin"]],
    swd_fengyu: ["male", "shu", 4, ["zhenwei", "shangxi"], ["fullskin"]]
  },
  skill: {
    miaobi: {
      enable: "phaseUse",
      viewAs: { name: "wugu" },
      filterCard: { suit: "heart" },
      filter: function(event, player) {
        return !player.getStat("skill").miaobi && player.num("h", { suit: "heart" }) > 0;
      },
      check: function(card) {
        return 5 - ai.get.value(card);
      }
    },
    huajing: {
      trigger: { source: "damageEnd" },
      filter: function(event, player) {
        return event.card && get.type(event.card, "trick") == "trick" && player.hp < player.maxHp;
      },
      content: function() {
        player.recover();
      }
    },
    pingxu: {
      mod: {
        globalFrom: function(from, to, current) {
          if (!from.get("e", "1")) return current - 1;
        },
        globalTo: function(from, to, current) {
          if (!to.get("e", "2")) return current + 1;
        }
      }
    },
    jufu: {
      trigger: { source: "damageBegin" },
      filter: function(event, player) {
        if (event.card && event.card.name == "sha" && player.get("e", "1")) return true;
        return false;
      },
      forced: true,
      content: function() {
        trigger.num++;
      }
    },
    bingfeng: {
      unique: true,
      enable: "phaseUse",
      filter: function(event, player) {
        return !player.storage.bingfeng;
      },
      init: function(player) {
        player.storage.bingfeng = false;
      },
      filterTarget: function(card, player, target) {
        return player != target && !target.isTurnedOver();
      },
      mark: true,
      multitarget: true,
      multiline: true,
      selectTarget: [1, 3],
      content: function() {
        "step 0";
        player.unmarkSkill("bingfeng");
        player.removeSkill("xuanzhou");
        player.loseMaxHp();
        player.storage.bingfeng = true;
        event.num = 0;
        player.turnOver();
        player.addSkill("bingfeng2");
        "step 1";
        if (num < targets.length) {
          var target = targets[num];
          if (!target.isTurnedOver()) {
            target.turnOver();
          }
          target.addSkill("bingfeng2");
          event.num++;
          event.redo();
        }
      },
      intro: {
        content: "limited"
      },
      ai: {
        order: 1,
        result: {
          target: function(player, target) {
            if (game.phaseNumber < game.players.length) return 0;
            if (game.phaseNumber < game.players.length * 2 && player.hp == player.maxHp) return 0;
            switch (lib.config.mode) {
              case "identity": {
                for (var i = 0; i < game.players.length; i++) {
                  if (game.players[i].ai.shown == 0) return 0;
                }
                switch (player.identity) {
                  case "zhu": {
                    if (ai.get.situation() >= 0) return 0;
                    if (get.population("fan") < 3) return 0;
                    return -1;
                  }
                  case "zhong": {
                    if (get.population("fan") < 3) return 0;
                    return -1;
                  }
                  case "nei":
                    return 0;
                  case "fan": {
                    if (get.population("fan") == 0) return 0;
                    if (get.population("zhong") < 2) return 0;
                    return -1;
                  }
                }
              }
              case "guozhan": {
                if (player.identity == "unknown") return 0;
                return get.population(player.identity) >= 3 ? -1 : 0;
              }
              case "versus": {
                return -1;
              }
              default: {
                return 0;
              }
            }
          }
        }
      }
    },
    bingfeng2: {
      mod: {
        cardEnabled: function() {
          return false;
        },
        cardUsable: function() {
          return false;
        },
        cardRespondable: function() {
          return false;
        },
        cardSavable: function() {
          return false;
        }
      },
      trigger: { player: "turnOverAfter" },
      forced: true,
      filter: function(event, player) {
        return !player.isTurnedOver();
      },
      content: function() {
        player.removeSkill("bingfeng2");
      }
    },
    yudun: {
      mod: {
        cardEnabled: function(card, player) {
          if (get.type(card, "trick") == "trick") return false;
        },
        cardRespondable: function(card, player) {
          if (get.type(card, "trick") == "trick") return false;
        },
        cardSavable: function(card, player) {
          if (get.type(card, "trick") == "trick") return false;
        },
        cardUsable: function(card, player) {
          if (get.type(card, "trick") == "trick") return false;
          if (card.name == "sha") return Infinity;
        }
      },
      enable: ["chooseToUse", "chooseToRespond"],
      filterCard: function(card) {
        return get.type(card, "trick") == "trick";
      },
      viewAs: { name: "sha" },
      check: function() {
        return 1;
      },
      ai: {
        effect: {
          target: function(card, player, target, current) {
            if (get.tag(card, "respondSha") && current < 0) return 0.6;
          }
        },
        respondSha: true,
        order: 4,
        useful: -1,
        value: -1
      }
    },
    guozao: {
      trigger: { global: "damageEnd" },
      forced: true,
      check: function(event, player) {
        for (var i = 0; i < game.players.length; i++) {
          if (ai.get.attitude(player, game.players[i]) > 2 && game.players[i].num("h") == 1) {
            return true;
          }
        }
        return false;
      },
      filter: function(event, player) {
        if (event.source == player) return false;
        if (get.distance(player, event.player) > 1) return false;
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].num("h")) return true;
        }
        return false;
      },
      content: function() {
        "step 0";
        var cards = [];
        if (ui.cardPile.childNodes.length < 3) {
          var discardcards = get.cards(3);
          for (var i = 0; i < discardcards.length; i++) {
            ui.discardPile.appendChild(discardcards[i]);
          }
        }
        for (var i = 0; i < 3; i++) {
          cards.push(ui.cardPile.childNodes[i]);
        }
        event.cards = cards;
        var dialog = ui.create.dialog("聒噪：选择一个目标将手牌替换", cards, "hidden");
        dialog.classList.add("noselect");
        var next = player.chooseTarget(true, dialog, function(card, player, target) {
          return target.num("h") > 0;
        }).ai = function(target) {
          var att = ai.get.attitude(player, target);
          var hs = target.get("h");
          var num = hs.length;
          if (num <= 1) return att * 2;
          if (num == 2) {
            for (var i = 0; i < cards.length; i++) {
              if (ai.get.value(cards[i]) > 6, target, "raw") return att;
            }
            if (target == player) {
              for (var i = 0; i < 2; i++) {
                if (ai.get.value(cards[i]) > 6, target, "raw") return -1;
              }
            }
            return att / 2;
          }
          if (num == 3) {
            if (target == player) {
              var num2 = 0;
              for (var i = 0; i < 3; i++) {
                num2 += ai.get.value(cards[i], player, "raw");
                num2 -= ai.get.value(hs[i], player, "raw");
              }
              if (num2 > 0) return 0.5;
              if (num2 < 0) return -0.5;
            }
            return 0;
          }
          return -att / 2;
        };
        "step 1";
        if (result.bool) {
          var target = result.targets[0];
          player.logSkill("guozao", target);
          var cards = target.get("h");
          target.lose(cards)._triggered = null;
          game.log(get.translation(target) + "弃置了" + get.translation(cards) + "，并获得三张牌");
          // target.$draw(3);
          target.$throw(cards);
          target.gain(event.cards, "draw")._triggered = null;
        } else {
          event.finish();
        }
      },
      ai: {
        expose: 0.1
      }
    },
    heihuo: {
      enable: "phaseUse",
      filter: function(event, player) {
        return player.num("h") > 0 && player.num("he", { type: "equip" }) > 0 && !player.skills.contains("heihuo2");
      },
      filterCard: function(card) {
        return get.type(card) == "equip";
      },
      position: "he",
      check: function(card) {
        var player = _status.currentPhase;
        var nh = player.num("h");
        var pos = get.position(card);
        if (nh < 2) return 0;
        if (nh > 5) return 0;
        if (nh == 5 && pos == "e") return 0;
        if (player.num("he", { subtype: get.subtype(card) }) > 1) {
          return 11 - ai.get.equipValue(card) + (pos == "e" ? 0.4 : 0);
        }
        // if(nh==6||(nh==5&&pos=='e')) return 8-ai.get.value(card);
        return 5.5 - ai.get.value(card) + (pos == "e" ? 0.4 : 0);
      },
      content: function() {
        "step 0";
        player.draw(player.num("h"));
        "step 1";
        if (player.num("h") >= 10) {
          player.damage(3, "fire");
          player.addTempSkill("heihuo2", "phaseAfter");
        }
      },
      ai: {
        order: 10,
        threaten: 1.4,
        result: {
          player: 1
        }
      }
    },
    heihuo2: {},
    yaotong: {
      group: ["yaotong1", "yaotong2", "yaotong3"],
      ai: {
        respondSha: true,
        respondShan: true
      },
      threaten: 1.3
    },
    yaotong1: {
      enable: ["chooseToRespond", "chooseToUse"],
      filterCard: true,
      viewAs: { name: "sha" },
      filter: function(event, player) {
        var num = player.num("h");
        if (num == 0) return false;
        return num % 2 == 1;
      },
      prompt: "将一张手牌当作杀打出",
      check: function(card) {
        return 6 - ai.get.value(card);
      }
    },
    yaotong2: {
      enable: ["chooseToRespond", "chooseToUse"],
      filterCard: true,
      viewAs: { name: "shan" },
      filter: function(event, player) {
        var num = player.num("h");
        if (num == 0) return false;
        return num % 2 == 1;
      },
      prompt: "将一张手牌当作闪打出",
      check: function(card) {
        return 6 - ai.get.value(card);
      }
    },
    yaotong3: {
      enable: "chooseToUse",
      filterCard: true,
      viewAs: { name: "wuxie" },
      filter: function(event, player) {
        var num = player.num("h");
        if (num == 0) return false;
        return num % 2 == 0;
      },
      viewAsFilter: function(player) {
        var num = player.num("h");
        if (num == 0) return false;
        return num % 2 == 0;
      },
      prompt: "将一张手牌当作无懈可击使用",
      check: function(card) {
        return 7 - ai.get.value(card);
      }
    },
    yaotong4: {
      enable: "chooseToUse",
      filterCard: true,
      viewAs: { name: "tao" },
      filter: function(event, player) {
        var num = player.num("h");
        if (num == 0) return false;
        return num % 2 == 0;
      },
      viewAsFilter: function(player) {
        var num = player.num("h");
        if (num == 0) return false;
        return num % 2 == 0;
      },
      prompt: "将一张手牌当作桃使用",
      check: function(card) {
        return 9 - ai.get.value(card);
      }
    },
    pojian: {
      trigger: { player: "loseEnd" },
      filter: function(event, player) {
        if (player.num("h")) return false;
        for (var i = 0; i < event.cards.length; i++) {
          if (event.cards[i].original == "h") return true;
        }
        return false;
      },
      content: function() {
        for (var i = 0; i < ui.cardPile.childNodes.length; i++) {
          if (get.type(ui.cardPile.childNodes[i]) == "equip") {
            player.equip(ui.cardPile.childNodes[i]);
            player.$gain2(ui.cardPile.childNodes[i]);
            game.delay();
            event.finish();
            return;
          }
        }
        for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
          if (get.type(ui.discardPile.childNodes[i]) == "equip") {
            player.equip(ui.discardPile.childNodes[i]);
            player.$gain2(ui.discardPile.childNodes[i]);
            game.delay();
            event.finish();
            return;
          }
        }
      }
    },
    kuangfu: {
      trigger: { source: "damageEnd" },
      direct: true,
      filter: function(event) {
        return event.card && event.card.name == "sha" && event.player.num("e");
      },
      content: function() {
        "step 0";
        var neg = ai.get.attitude(player, trigger.player) <= 0;
        player.choosePlayerCard("e", trigger.player).ai = function(button) {
          if (neg) {
            return ai.get.buttonValue(button);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("kuangfu");
          trigger.player.$give(result.links, player);
          game.delay(2);
          player.equip(result.links[0]);
        }
      }
    },
    huajin: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("he") > 0;
      },
      filterCard: true,
      position: "he",
      content: function() {
        player.addSkill("huajin2");
      },
      check: function(card) {
        return 5 - ai.get.value(card);
      },
      ai: {
        order: 10,
        result: {
          player: function(player) {
            if (player.num("h", "juedou")) return 1;
            if (player.num("h", "sha") == 0) return 0;
            for (var i = 0; i < game.players.length; i++) {
              if (player.canUse("sha", game.players[i]) &&
                ai.get.effect(game.players[i], { name: "sha" }, player, player) > 0) {
                return 1;
              }
            }
            return 0;
          }
        }
      }
    },
    huajin2: {
      trigger: { source: "damageBegin" },
      forced: true,
      content: function() {
        trigger.num++;
      },
      group: "huajin3"
    },
    huajin3: {
      trigger: { player: "phaseBegin" },
      forced: true,
      popup: false,
      content: function() {
        player.removeSkill("huajin2");
      }
    },
    yuchen: {
      trigger: { player: ["useCard", "respondAfter"] },
      direct: true,
      filter: function(event, player) {
        if (player == _status.currentPhase) return false;
        if (event.cards) {
          for (var i = 0; i < event.cards.length; i++) {
            if (get.color(event.cards[i]) == "black") return true;
          }
        }
        return false;
      },
      content: function() {
        "step 0";
        game.delay(0.5);
        player.chooseTarget("是否发动【浴尘】？", function(card, player, target) {
          return player != target && target.num("he") > 0;
        }).ai = function(target) {
          return -ai.get.attitude(player, target);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("yuchen", result.targets);
          player.discardPlayerCard(result.targets[0], true);
        }
      },
      ai: {
        threaten: 0.7
      }
    },
    bingjian: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("he", { color: "black", name: "sha" }) > 0;
      },
      filterCard: function(card) {
        return card.name == "sha" && get.color(card) == "black";
      },
      filterTarget: function(card, player, target) {
        return player != target && target.num("h") > 0;
      },
      line: "thunder",
      content: function() {
        "step 0";
        target.showHandcards();
        "step 1";
        var cards = target.get("h", "shan");
        if (cards.length) {
          target.discard(cards);
        } else {
          target.damage("thunder");
        }
      },
      ai: {
        order: 5,
        result: {
          target: function(player, target) {
            return ai.get.damageEffect(target, player, target, "thunder");
          }
        },
        expose: 0.2
      }
    },
    rumeng: {
      trigger: { global: "phaseUseBefore" },
      direct: true,
      filter: function(event, player) {
        return event.player != player && player.num("he", { type: "basic" }) < player.num("he");
      },
      content: function() {
        "step 0";
        var yep = ai.get.attitude(player, trigger.player) < 0 &&
          trigger.player.num("h") > 2;
        player.chooseToDiscard(function(card) {
          return get.type(card) != "basic";
        }, "是否对" + get.translation(trigger.player) + "发动【入梦】？", "he").ai = function(card) {
          if (yep) {
            return 6 - ai.get.value(card);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("rumeng", trigger.player);
          trigger.player.chooseToDiscard({ type: "basic" }, "入梦：弃置一张基本牌或路过出牌及弃牌阶段").ai = function(card) {
            return 5 - ai.get.value(card);
          };
        } else {
          event.finish();
        }
        "step 2";
        if (!result.bool) {
          trigger.untrigger();
          trigger.finish();
          trigger.player.skip("phaseDiscard");
        }
      },
      ai: {
        expose: 0.1
      }
    },
    lianda: {
      trigger: { player: "shaAfter" },
      direct: true,
      filter: function(event, player) {
        return event.target.isAlive() && player.num("he") > 0 && !player.skills.contains("lianda2");
      },
      content: function() {
        "step 0";
        player.chooseToDiscard("he", "是否发动【连打】？").ai = function(card) {
          if (ai.get.effect(trigger.target, { name: "sha" }, player, player) > 0) {
            return 7 - ai.get.value(card);
          }
        };
        "step 1";
        if (result.bool) {
          player.logSkill("lianda");
          player.addTempSkill("lianda2", "phaseAfter");
          player.useCard({ name: "sha" }, trigger.target);
        }
      }
    },
    lianda2: {},
    huiqi: {
      trigger: { player: "changeHp" },
      direct: true,
      filter: function(event, player) {
        return event.num < 0 && player.hp < player.maxHp;
      },
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【回气】？").ai = function(target) {
          var att = ai.get.attitude(player, target);
          if (player.hp <= 0) {
            if (player == target) {
              return 1;
            }
            if (att > 3) {
              return att + Math.max(0, 5 - target.num("h"));
            }
            return att / 4;
          }
          if (att > 3) {
            return att + Math.max(0, 5 - target.num("h"));
          }
          return att;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("huiqi", result.targets);
          result.targets[0].draw(Math.min(3, player.maxHp - player.hp));
        }
      },
      ai: {
        expose: 0.2,
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              return [1, 0.5];
            }
          }
        }
      }
    },
    xianghui: {
      enable: "phaseUse",
      usable: 1,
      filterCard: { color: "red" },
      filter: function() {
        var min = game.players[0].hp;
        for (var i = 0; i < game.players.length; i++) {
          min = Math.min(min, game.players[i].hp);
        }
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].hp == min && game.players[i].hp < game.players[i].maxHp) return true;
        }
        return false;
      },
      prompt: function() {
        var targets = [];
        var min = game.players[0].hp;
        for (var i = 0; i < game.players.length; i++) {
          min = Math.min(min, game.players[i].hp);
        }
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].hp == min && game.players[i].hp < game.players[i].maxHp) {
            targets.push(game.players[i]);
          }
        }
        return "令" + get.translation(targets) + "回复一点体力";
      },
      check: function(card) {
        return 8 - ai.get.value(card);
      },
      filterTarget: function(card, player, target) {
        if (target.hp == target.maxHp) return false;
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].hp < target.hp) return false;
        }
        return true;
      },
      selectTarget: -1,
      content: function() {
        target.recover();
      },
      ai: {
        expose: 0.1,
        order: 9,
        threaten: 1.4,
        result: {
          player: function(player, target) {
            var num = 0;
            var min = game.players[0].hp;
            for (var i = 0; i < game.players.length; i++) {
              min = Math.min(min, game.players[i].hp);
            }
            for (var i = 0; i < game.players.length; i++) {
              if (game.players[i].hp == min && game.players[i].hp < game.players[i].maxHp) {
                num += ai.get.recoverEffect(game.players[i], player, player);
              }
            }
            return num;
          }
        }
      }
    },
    hzhenwei: {
      trigger: { global: "shaBefore" },
      direct: true,
      priority: 5,
      filter: function(event, player) {
        if (player == event.target || player == event.player) return false;
        if (!player.num("he")) return false;
        return get.distance(event.player, player, "attack") <= 1;
      },
      content: function() {
        "step 0";
        var save = false;
        if (ai.get.attitude(player, trigger.target) > 2) {
          if (player.num("h", "shan") || player.num("e", "2") ||
            trigger.target.hp == 1 || player.hp > trigger.target.hp + 1) {
            if (!trigger.target.num("h", "shan") || trigger.target.num("h") < player.num("h")) {
              save = true;
            }
          }
        }
        player.chooseToDiscard("he", "是否发动【镇卫】？").ai = function(card) {
          if (save) {
            return 7 - ai.get.value(card);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("hzhenwei", trigger.target);
          trigger.target = player;
          trigger.untrigger();
          trigger.trigger("useCardToBefore");
          trigger.trigger("shaBefore");
          player.addSkill("hzhenwei2");
          game.delay();
        }
      },
      ai: {
        effect: {
          target: function(card) {
            if (card.name == "sha") return 1.3;
          }
        }
      }
    },
    hzhenwei2: {
      trigger: { target: "shaAfter" },
      forced: true,
      popup: false,
      content: function() {
        player.draw();
        player.removeSkill("hzhenwei2");
      }
    },
    zhenwei: {
      trigger: { global: "respondEnd" },
      filter: function(event, player) {
        if (get.distance(player, event.player, "attack") > 1) return false;
        if (event.player == player) return false;
        if (event.cards) {
          for (var i = 0; i < event.cards.length; i++) {
            if (get.position(event.cards[i]) == "d") return true;
          }
        }
        return false;
      },
      direct: true,
      content: function() {
        "step 0";
        var cards = trigger.cards.slice(0);
        for (var i = 0; i < cards.length; i++) {
          if (get.position(cards[i]) != "d") {
            cards.splice(i--, 1);
          }
        }
        event.cards = cards;
        game.delay(0.5);
        player.chooseTarget("是否发动【镇威】？", function(card, player, target) {
          return target != trigger.player;
        }).ai = function(target) {
          var att = ai.get.attitude(player, target);
          if (att <= 0) return 0;
          if (att > 3) {
            return 100 - target.num("h");
          }
          return att;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("zhenwei");
          game.log(get.translation(result.targets[0]) + "获得了" + get.translation(event.cards));
          result.targets[0].gain(event.cards, "gain2");
        }
      },
      ai: {
        expose: 0.1,
        threaten: 1.6
      }
    },
    shangxi: {
      trigger: { player: "phaseUseBegin" },
      direct: true,
      filter: function(event, player) {
        if (player.num("he") == 0) return false;
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i] != player &&
            get.distance(player, game.players[i], "attack") <= 1 &&
            player.hp <= game.players[i].hp) {
            return true;
          }
        }
        return false;
      },
      content: function() {
        "step 0";
        var next = player.chooseCardTarget({
          position: "he",
          filterTarget: function(card, player, target) {
            return get.distance(player, target, "attack") <= 1 &&
              player != target && player.hp <= target.hp;
          },
          filterCard: true,
          ai1: function(card) {
            return 9 - ai.get.value(card);
          },
          ai2: function(target) {
            return ai.get.damageEffect(target, player, player);
          },
          prompt: "是否发动【伤袭】？"
        });
        "step 1";
        if (result.bool) {
          player.discard(result.cards);
          player.logSkill("shangxi", result.targets);
          result.targets[0].damage();
        }
      },
      ai: {
        expose: 0.3
      }
    },
    fuyan: {
      trigger: { player: "damageEnd" },
      filter: function(event) {
        return event.num > 0;
      },
      content: function() {
        "step 0";
        player.draw();
        "step 1";
        if (player.num("he")) {
          player.chooseCardTarget({
            position: "he",
            prompt: "选择一张牌作为“岩”",
            ai1: function(card) {
              return 8 - ai.get.value(card);
            },
            ai2: function(target) {
              var eff = -ai.get.damageEffect(target, target, player);
              return eff + (player == target ? 2 : 0);
            },
            filterCard: true,
            filterTarget: function(card, player, target) {
              return !target.skills.contains("fuyan2");
            }
          });
        } else {
          event.finish();
        }
        "step 2";
        if (result.bool) {
          player.line(result.targets);
          player.lose(result.cards, ui.special);
          var target = result.targets[0];
          target.storage.fuyan2 = result.cards[0];
          target.addSkill("fuyan2");
          player.$give(result.cards, target);
          game.log(get.translation(player) + "将" + get.translation(result.cards) + "置于" + get.translation(target) + "的武将牌上");
        }
      },
      ai: {
        effect: {
          target: function(card, player) {
            if (get.tag(card, "damage")) {
              if (player.skills.contains("jueqing")) return [1, -2];
              return 0.7;
            }
          }
        },
        expose: 0.2
      }
    },
    fuyan2: {
      trigger: { player: "damageBegin" },
      filter: function(event, player) {
        return event.num > 0;
      },
      forced: true,
      mark: "card",
      content: function() {
        trigger.num--;
        player.removeSkill("fuyan2");
        ui.discardPile.appendChild(player.storage.fuyan2);
        delete player.storage.fuyan2;
      },
      intro: {
        content: "card"
      }
    },
    pingshen: {
      trigger: { source: "damageBegin" },
      forced: true,
      popup: false,
      unique: true,
      silent: true,
      content: function() {
        trigger.player.addSkill("pingshen2");
        trigger.player.storage.pingshen = player;
      }
    },
    pingshen2: {
      enable: "phaseUse",
      unique: true,
      mark: true,
      init: function(player) {
        player.storage.pingshen2 = false;
      },
      filter: function(event, player) {
        return !player.storage.pingshen2;
      },
      filterCard: true,
      filterTarget: function(card, player, target) {
        return target == player.storage.pingshen;
      },
      selectTarget: -1,
      position: "he",
      content: function() {
        player.storage.pingshen2 = true;
        player.unmarkSkill("pingshen2");
        player.gain(target.get("h"));
        target.$give(target.num("h"), player);
        player.turnOver();
        player.addSkill("pingshen3");
      },
      check: function(card) {
        return 8 - ai.get.value(card);
      },
      intro: {
        content: "limited"
      },
      ai: {
        order: 10,
        result: {
          player: function(player) {
            if (player.classList.contains("turnedover")) return 10;
            if (ai.get.attitude(player, player.storage.pingshen) >= 0) {
              return 0;
            }
            if (player.storage.pingshen.num("h") > player.storage.pingshen.hp) return 1;
            return 0;
          }
        },
        effect: {
          target: function(card, player, target) {
            if (!target.storage.pingshen2) {
              if (card.name == "guiyoujie") return [0, 1];
            }
          }
        }
      }
    },
    pingshen3: {
      trigger: { player: "phaseUseEnd" },
      forced: true,
      popup: false,
      content: function() {
        "step 0";
        player.removeSkill("pingshen3");
        if (player.storage.pingshen.classList.contains("dead")) {
          event.finish();
        } else {
          player.chooseCard("he", true, player.storage.pingshen.hp);
        }
        "step 1";
        player.storage.pingshen.gain(result.cards);
        player.$give(result.cards.length, player.storage.pingshen);
      }
    },
    guaili: {
      trigger: { source: "damageBegin" },
      filter: function(event) {
        return event.card && event.card.name == "sha";
      },
      forced: true,
      content: function() {
        trigger.num++;
      },
      ai: {
        threaten: 1.2
      }
    },
    xingzhui: {
      enable: "phaseUse",
      usable: 1,
      filterCard: true,
      position: "he",
      filterTarget: function(card, player, target) {
        return player != target && target.num("he") > 0;
      },
      check: function(card) {
        if (get.type(card) == "equip") {
          var distance = get.info(card).distance;
          if (distance) {
            if (distance.attackFrom < 0 || distance.globalFrom < 0) return 10;
          }
        }
        return 7 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        if (!target.num("he")) {
          event.finish();
        } else {
          event.type = get.type(cards[0], "trick");
          var dme = ai.get.damageEffect(target, player, target);
          target.chooseToDiscard("he", true, "星坠：请弃置一张牌（若不是" + get.translation(event.type) + "牌则受到1点伤害）").ai = function(card) {
            var val = ai.get.value(card);
            if (get.type(card, "trick") == event.type) {
              return -dme - ai.get.value(card);
            }
            return -ai.get.value(card);
          };
        }
        "step 1";
        if (result.bool) {
          if (get.type(result.cards[0], "trick") != event.type) {
            target.damage();
          }
        }
      },
      ai: {
        order: 9,
        result: {
          target: function(player, target) {
            return ai.get.damageEffect(target, player) - 0.1;
          }
        },
        threaten: 2,
        expose: 0.2
      }
    },
    lingxian: {
      trigger: { player: ["respond", "useCard"] },
      direct: true,
      filter: function(event, player) {
        if (player == _status.currentPhase) return false;
        if (get.itemtype(event.cards) != "cards") return false;
        for (var i = 0; i < game.players.length; i++) {
          if (get.distance(player, game.players[i], "attack") > 1 && player != game.players[i]) {
            return true;
          }
        }
        return false;
      },
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【凌仙】？", function(card, player, target) {
          return get.distance(player, target, "attack") > 1 && player != target;
        }).ai = function(target) {
          var att = ai.get.attitude(player, target);
          if (att <= -0.5) return 0;
          if (att <= 3) return att + 0.5;
          return att + Math.min(0.5, 5 - target.num("h"));
        };
        "step 1";
        if (result.bool) {
          game.asyncDraw([player, result.targets[0]]);
          player.logSkill("lingxian", result.targets);
        }
      },
      ai: {
        mingzhi: false,
        effect: {
          target: function(card, player, target) {
            if (get.type(card) == "equip" && player == target) {
              var distance = get.info(card).distance;
              if (distance) {
                if (distance.attackFrom < 0 || distance.globalFrom < 0) return 0;
              }
            } else {
              var hs = target.num("h");
              if (get.tag(card, "respondShan")) {
                var shans = target.num("h", "shan");
                if (shans > 1) return [0, 1];
                if (shans && hs > 2) return [0, 1];
                if (shans) return [0, 0];
                if (hs > 2) return [0, 0];
                if (hs > 1) return [1, 0.5];
                return [1.5, 0];
              }
              if (get.tag(card, "respondSha")) {
                var shas = target.num("h", "sha");
                if (shas > 1) return [0, 1];
                if (shas && hs > 2) return [0, 1];
                if (shas) return [0, 0];
                if (hs > 2) return [0, 0];
                if (hs > 1) return [1, 0.5];
                return [1.5, 0];
              }
            }
          }
        },
        threaten: 0.8,
        expose: 0.1
      }
    },
    shouyin: {
      unique: true,
      enable: "chooseToUse",
      init: function(player) {
        player.storage.shouyin = false;
      },
      mark: true,
      filter: function(event, player) {
        if (event.type != "dying") return false;
        if (player.storage.shouyin) return false;
        if (player.isTurnedOver()) return false;
        return true;
      },
      content: function() {
        "step 0";
        player.unmarkSkill("shouyin");
        player.storage.shouyin = true;
        player.turnOver();
        "step 1";
        event.targets = game.players.slice(0);
        event.targets.sort(lib.sort.seat);
        "step 2";
        if (event.targets.length) {
          var target = event.targets.shift();
          if (target.hp < target.maxHp) {
            target.recover(target.maxHp - target.hp);
          }
          event.redo();
        }
      },
      ai: {
        expose: 0.3,
        save: true,
        result: {
          player: function(player) {
            if (_status.dying != player && ai.get.attitude(player, _status.dying) <= 0) {
              return 0;
            }
            var num = 0;
            for (var i = 0; i < game.players.length; i++) {
              var att = ai.get.attitude(player, game.players[i]);
              var del = game.players[i].maxHp - game.players[i].hp;
              if (att > 0) {
                num += del;
              } else if (att < 0) {
                num -= del;
              }
            }
            return num;
          }
        }
      },
      intro: {
        content: "limited"
      }
    },
    sliufeng: {
      mod: {
        targetInRange: function(card, player, target) {
          if (card.name == "sha" && player.hp >= target.hp) {
            return true;
          }
        }
      }
    },
    linyun: {
      enable: "chooseToUse",
      filterCard: true,
      selectCard: 2,
      position: "he",
      viewAs: { name: "sha" },
      prompt: "将两张牌当杀使用",
      check: function(card) {
        if (_status.event.player.num("h") < 4) return 6 - ai.get.useful(card);
        return 7 - ai.get.useful(card);
      },
      ai: {
        order: function() {
          return lib.card.sha.ai.order + 0.1;
        }
      },
      group: ["linyun2", "linyun3"]
    },
    linyun2: {
      trigger: { player: "shaBegin" },
      filter: function(event) {
        return event.skill == "linyun";
      },
      forced: true,
      popup: false,
      content: function() {
        "step 0";
        var next = trigger.target.chooseToRespond({ name: "shan" });
        next.autochoose = lib.filter.autoRespondShan;
        next.ai = function(card) {
          if (trigger.target.num("h", "shan") > 1) {
            return ai.get.unuseful2(card);
          }
          return -1;
        };
        "step 1";
        if (result.bool == false) {
          trigger.untrigger();
          trigger.directHit = true;
        }
      },
      ai: {
        threaten: 1.3
      }
    },
    linyun3: {
      trigger: { source: "damageAfter" },
      forced: true,
      popup: false,
      filter: function(event, player) {
        return event.parent.skill == "linyun" && !player.skills.contains("linyun4");
      },
      content: function() {
        player.draw();
        player.addTempSkill("linyun4", "shaAfter");
      }
    },
    linyun4: [],
    bofeng: {
      mod: {
        targetInRange: function(card, player, target) {
          if (card.name == "sha" && player.hp >= target.hp) {
            return true;
          }
        }
      },
      trigger: { player: "shaBegin" },
      check: function(event, player) {
        return ai.get.attitude(player, event.target) < 0;
      },
      content: function() {
        "step 0";
        trigger.target.chooseToRespond({ name: "shan" });
        "step 1";
        if (result.bool == false) {
          trigger.untrigger();
          trigger.directHit = true;
          player.addTempSkill("bofeng2", "shaEnd");
        }
      },
      ai: {
        threaten: 1.3
      }
    },
    bofeng2: {
      trigger: { source: "damageBegin" },
      filter: function(event) {
        return (event.card && (event.card.name == "sha") && event.parent.name != "_lianhuan" && event.parent.name != "_lianhuan2");
      },
      forced: true,
      popup: false,
      content: function() {
        trigger.num++;
      }
    },
    hutian: {
      trigger: { player: "phaseEnd" },
      direct: true,
      filter: function(event, player) {
        return player.num("h") > 0 && !player.storage.hutian;
      },
      content: function() {
        "step 0";
        var next = player.chooseCardTarget({
          filterTarget: function(card, player, target) {
            return target.maxHp >= ui.selected.cards.length;
          },
          filterCard: true,
          selectCard: [1, Infinity],
          ai1: function(card) {
            if (ui.selected.cards.length == 0 && player.hp == 1) return 11 - ai.get.value(card);
            if (ui.selected.cards.length > 1) return 0;
            return 7 - ai.get.useful(card);
          },
          ai2: function(target) {
            if (target.hp > ui.selected.cards.length) {
              return 0;
            }
            return ai.get.attitude(player, target);
          },
          prompt: "是否发动【护天】？"
        });
        "step 1";
        if (result.bool) {
          var target = result.targets[0];
          event.target = target;
          player.$give(result.cards, target);
          player.lose(result.cards, ui.special);
          player.storage.hutian = target;
          player.logSkill("hutian", result.targets);
          player.addTempSkill("hutian4", "phaseAfter");
          target.addSkill("hutian2");
          target.storage.hutian2 = result.cards;
        } else {
          event.finish();
        }
        "step 2";
        var target = event.target;
        if (target.storage.hutian2 && target.hp < target.storage.hutian2.length) {
          target.recover(target.storage.hutian2.length - target.hp);
        }
      },
      ai: {
        expose: 0.2,
        threaten: 1.5
      },
      group: "hutian3"
    },
    hutian2: {
      trigger: { player: ["damageBegin", "loseHpBegin"] },
      forced: true,
      priority: -55,
      mark: true,
      filter: function(event, player) {
        return player.hp - event.num < player.storage.hutian2.length;
      },
      content: function() {
        trigger.num = player.hp - player.storage.hutian2.length;
      },
      intro: {
        content: "cards"
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage") || get.tag(card, "loseHp")) {
              if (target.hp <= target.storage.hutian2.length) return 0;
            }
          }
        }
      }
    },
    hutian3: {
      trigger: { player: ["phaseEnd", "dieBegin"] },
      forced: true,
      filter: function(event, player) {
        if (player.skills.contains("hutian4")) return false;
        return player.storage.hutian ? true : false;
      },
      priority: -1,
      content: function() {
        var target = player.storage.hutian;
        target.gain(target.storage.hutian2, "gain2");
        delete target.storage.hutian2;
        delete player.storage.hutian;
        target.removeSkill("hutian2");
      }
    },
    hutian4: {},
    chengjian: {
      trigger: { global: "damageEnd" },
      check: function(event, player) {
        return ai.get.attitude(player, event.source) > 0;
      },
      filter: function(event, player) {
        return event.source && event.card && event.card.name == "sha" && event.source != player;
      },
      content: function() {
        trigger.source.draw();
      },
      ai: {
        expose: 0.1,
        threaten: 1.2
      }
    },
    huanxing: {
      trigger: { player: "phaseBegin" },
      group: "huanxing2",
      direct: true,
      filter: function(event, player) {
        return player.num("he") > 0;
      },
      content: function() {
        "step 0";
        player.unmark(player.storage.huanxing + "_charactermark");
        delete player.storage.huanxing;
        delete player.additionalSkills.huanxing;
        player.checkMarks();
        player.chooseCardTarget({
          prompt: "是否发动【幻形】？",
          filterCard: true,
          position: "he",
          filterTarget: function(card, player, target) {
            if (target == player) return false;
            if (target.sex != "male") return false;
            var name = target.name.indexOf("unknown") == 0 ? target.name2 : target.name;

            var info = lib.character[name];
            if (info) {
              var skills = info[3];
              for (var j = 0; j < skills.length; j++) {
                if (lib.translate[skills[j] + "_info"] && lib.skill[skills[j]] &&
                  !lib.skill[skills[j]].unique && !player.skills.contains(skills[j])) {
                  return true;
                }
              }
            }
            return false;
          },
          ai1: function(card) {
            return 7 - ai.get.value(card);
          },
          ai2: function(target) {
            return 6 - target.maxHp;
          }
        });
        "step 1";
        if (result.bool) {
          player.discard(result.cards);
          player.logSkill("huanxing", result.targets);
          var name = result.targets[0].name;
          if (name.indexOf("unknown") == 0) {
            name = result.targets[0].name2;
          }
          var list = [];
          var skills = lib.character[name][3];
          for (var j = 0; j < skills.length; j++) {
            if (lib.translate[skills[j] + "_info"] && lib.skill[skills[j]] &&
              !lib.skill[skills[j]].unique && !player.skills.contains(skills[j])) {
              list.push(skills[j]);
            }
          }
          for (var i = 0; i < list.length; i++) {
            player.addSkill(list[i]);
            player.skills.remove(list[i]);
          }
          player.additionalSkills.huanxing = list;
          player.markCharacter(name, null, true, true);
          player.storage.huanxing = name;
        }
      },
      ai: {
        threaten: 1.5
      }
    },
    huanxing2: {
      trigger: { player: "damageAfter" },
      priority: -15,
      forced: true,
      filter: function(event, player) {
        return player.additionalSkills.huanxing ? true : false;
      },
      content: function() {
        player.unmark(player.storage.huanxing + "_charactermark");
        delete player.storage.huanxing;
        delete player.additionalSkills.huanxing;
        player.checkMarks();
      }
    },
    guiying: {
      enable: "chooseToUse",
      filterCard: function(card) {
        return get.color(card) == "black";
      },
      position: "he",
      viewAs: { name: "toulianghuanzhu" },
      prompt: "将一张黑色牌当偷梁换柱使用",
      check: function(card) {
        if (_status.event.player.num("h") > _status.event.player.hp) {
          return 5 - ai.get.value(card);
        }
        return 0;
      }
    },
    suiyan: {
      trigger: { source: "damageEnd" },
      // group:'unequip',
      check: function(event, player) {
        return ai.get.attitude(player, event.player) < 0;
      },
      direct: true,
      filter: function(event, player) {
        return event.player.num("e");
      },
      content: function() {
        "step 0";
        var att = ai.get.attitude(player, trigger.player);
        player.chooseToDiscard("he", "是否发动【碎岩】？").ai = function(card) {
          if (att < 0) return 7 - ai.get.value(card);
          return -1;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("suiyan", trigger.player);
          trigger.player.discard(trigger.player.get("e"));
        }
      },
      ai: {
        expose: 0.3
      }
    },
    ningxian: {
      trigger: { player: "damageEnd" },
      direct: true,
      filter: function(event, player) {
        return player.num("he", { color: "black" }) > 0;
      },
      content: function() {
        "step 0";
        var enemy = 0;
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i] != player && ai.get.damageEffect(game.players[i], player, player) > 0) {
            enemy++;
          }
        }
        var next = player.chooseCardTarget({
          position: "he",
          filterTarget: function(card, player, target) {
            return player != target;
          },
          selectCard: [1, player.num("he", { color: "black" })],
          selectTarget: function() {
            if (ui.selected.targets.length > ui.selected.cards.length) {
              game.uncheck("target");
            }
            return ui.selected.cards.length;
          },
          filterCard: { color: "black" },
          ai1: function(card) {
            if (ui.selected.cards.length >= enemy) return 0;
            return 9 - ai.get.value(card);
          },
          ai2: function(target) {
            return ai.get.damageEffect(target, player, player);
          },
          prompt: "是否发动【凝霰】？"
        });
        "step 1";
        if (result.bool) {
          player.discard(result.cards);
          player.logSkill("ningxian", result.targets);
          event.targets = result.targets;
          event.targets.sort(lib.sort.seat);
        } else {
          event.finish();
        }
        "step 2";
        if (event.targets.length) {
          event.targets.shift().damage();
          event.redo();
        }
      },
      ai: {
        maixie: true,
        effect: function(card, player, target) {
          if (get.tag(card, "damage")) {
            if (player.skills.contains("jueqing")) return [1, -0.5];
            if (player.num("h") > 2 || player.num("e", { color: "black" })) {
              return [1, 0, 0, -1];
            }
            return [1, -0.5];
          }
        }
      }
    },
    xuanyuan: {},
    jilve: {
      enable: "phaseUse",
      group: "jilve6",
      direct: true,
      // usable:3,
      delay: 0,
      content: function() {
        "step 0";
        player.getStat("skill").jilve--;
        var cards = [];
        var max = Math.min(2, ui.cardPile.childNodes.length);
        for (var i = 0; i < max; i++) {
          cards.push(ui.cardPile.childNodes[i]);
        }
        for (var i = max; i < 2; i++) {
          cards.push(ui.discardPile.childNodes[i]);
        }
        var dialog = ui.create.dialog("极略：选择一张基本牌或锦囊牌牌使用", cards);
        var trigger = event.parent.parent;
        player.chooseButton(dialog, function() {
          return 1;
        }).filterButton = function(button) {
          var type = get.type(button.link, "trick");
          return (type == "trick" || type == "basic") && trigger.filterCard(button.link, player, trigger);
        };
        player.addTempSkill("jilve3", ["useCardAfter", "phaseAfter"]);
        "step 1";
        if (result.bool) {
          // player.getStat('skill').jilve++;
          lib.skill.jilve2.viewAs = result.buttons[0].link;
          event.parent.parent.backup("jilve2");
          event.parent.parent.step = 0;
          if (event.isMine()) {
            event.parent.parent.openskilldialog = "选择" + get.translation(result.buttons[0].link) + "的目标";
          }
        }
      },
      ai: {
        order: 12,
        result: {
          player: function(player) {
            if (player.tempSkills["jilve3"]) return 0;
            if (_status.dying) return ai.get.attitude(player, _status.dying);
            return 1;
          }
        },
        threaten: 1.7
      }
    },
    jilve6: {
      trigger: { player: "useCardBefore" },
      forced: true,
      popup: false,
      filter: function(event, player) {
        return event.skill == "jilve2";
      },
      content: function() {
        player.getStat("skill").jilve++;
      }
    },
    jilve2: {
      filterCard: function() {
        return false;
      },
      selectCard: -1
    },
    jilve3: {},
    jilve4: {
      trigger: { player: "useCard" },
      forced: true,
      popup: false,
      filter: function(event) {
        return event.skill == "jilve2";
      },
      content: function() {
        player.storage.jilve++;
      }
    },
    jilve5: {
      trigger: { player: "phaseUseBegin" },
      forced: true,
      popup: false,
      content: function() {
        player.storage.jilve = 0;
      }
    },
    pozhou: {
      unique: true,
      trigger: { player: "damageEnd" },
      forced: true,
      init: function(player) {
        player.storage.pozhou = 0;
      },
      content: function() {
        player.storage.pozhou += trigger.num;
        if (player.storage.pozhou) {
          player.markSkill("pozhou");
        }
      },
      intro: {
        content: "mark"
      },
      group: "pozhou2",
      ai: {
        maixie: true,
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              if (player.skills.contains("jueqing")) return [1, -1.5];
              if (player.hp >= 4) return [1, 1.5];
              if (target.hp == 3) return [1, 1];
              if (target.hp == 2) return [1, 0.5];
            }
          }
        }
      }
    },
    pozhou2: {
      trigger: { global: "phaseBegin" },
      priority: -5,
      check: function(event, player) {
        return ai.get.attitude(player, event.player) < -3;
      },
      filter: function(event, player) {
        return player.storage.pozhou > 0 && player != event.player;
      },
      prompt: function(event, player) {
        return "是否弃置一枚破咒标记令" + get.translation(event.player) +
          "的非锁定技失效？（剩余" + player.storage.pozhou + "枚）";
      },
      content: function() {
        player.storage.pozhou--;
        if (!player.storage.pozhou) {
          player.unmarkSkill("pozhou");
        }
        var target = trigger.player;
        target.disabledSkills.pozhou = [];
        for (var i = 0; i < target.skills.length; i++) {
          if (!get.skillLocked(target.skills[i])) {
            target.disabledSkills.pozhou.push(target.skills[i]);
          }
        }
        target.addSkill("pozhou3");
      }
    },
    pozhou3: {
      trigger: { player: "phaseBegin" },
      forced: true,
      mark: true,
      content: function() {
        delete player.disabledSkills.pozhou;
        player.removeSkill("pozhou3");
      },
      intro: {
        content: function(st, player) {
          var storage = player.disabledSkills.pozhou;
          if (storage && storage.length) {
            var str = "失效技能：";
            for (var i = 0; i < storage.length; i++) {
              if (lib.translate[storage[i] + "_info"]) {
                str += get.translation(storage[i]) + "、";
              }
            }
            return str.slice(0, str.length - 1);
          }
        }
      }
    },
    fengmo: {
      enable: "phaseUse",
      usable: 1,
      filter: function() {
        var num = 0;
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].get("e", "1")) {
            num++;
          }
        }
        return num >= 1;
      },
      filterTarget: function(card, player, target) {
        return player != target && !target.isTurnedOver();
      },
      content: function() {
        "step 0";
        event.targets = [];
        event.num = 0;
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].get("e", "1")) {
            event.targets.push(game.players[i]);
          }
        }
        event.targets.sort(lib.sort.seat);
        "step 1";
        if (num < event.targets.length) {
          var targetn = event.targets[num];
          var card = targetn.get("e", "1");
          if (card) {
            targetn.discard(card);
          }
          event.num++;
          event.redo();
        }
        "step 2";
        target.draw(event.targets.length);
        "step 3";
        target.turnOver();
      },
      ai: {
        result: {
          target: function(player, target) {
            var num = 0;
            for (var i = 0; i < game.players.length; i++) {
              if (game.players[i].get("e", "1")) {
                num++;
              }
            }
            if (target.hp == 1 && num < 3) {
              return (num - 3) / 1.5;
            }
            return num - 3;
          }
        },
        order: 10,
        expose: 0.1
      }
    },
    duanyue: {
      enable: "phaseUse",
      usable: 1,
      position: "he",
      filterCard: { type: "equip" },
      check: function(card) {
        var player = _status.currentPhase;
        if (player.num("he", { subtype: get.subtype(card) }) > 1) {
          return 12 - ai.get.equipValue(card);
        }
        return 8 - ai.get.equipValue(card);
      },
      filter: function(event, player) {
        return player.num("he", { type: "equip" });
      },
      filterTarget: function(card, player, target) {
        return player != target;
      },
      content: function() {
        "step 0";
        target.damage();
        "step 1";
        if (target.isAlive()) {
          var cards = target.get("h");
          event.num = cards.length;
          target.discard(cards);
        } else {
          event.finish();
        }
        "step 2";
        if (event.num > 2) {
          player.loseHp();
        }
      },
      ai: {
        order: 9,
        expose: 0.2,
        result: {
          target: function(player, target) {
            if (ai.get.damageEffect(target, player) < 0) {
              return -target.num("h") - (target.hp == 1 ? 1 : 0);
            }
          }
        }
      }
    },
    mojian: {
      trigger: { player: "shaBegin" },
      check: function(event, player) {
        if (ai.get.attitude(player, event.target) > 0) return true;
        return player.hp < player.maxHp;
      },
      // filter:function(event){
      // 	return event.player.isAlive();
      // },
      content: function() {
        "step 0";
        trigger.target.draw();
        "step 1";
        player.recover();
      }
    },
    liuhong: {
      trigger: { player: ["useCard", "respondAfter"] },
      frequent: true,
      filter: function(event) {
        return event.card && event.card.name == "sha";
      },
      content: function() {
        player.draw();
      }
    },
    poyue: {
      mod: {
        targetInRange: function(card, player) {
          if (card.name == "sha" && get.color(card) == "black") return true;
        },
        cardUsable: function(card) {
          if (card.name == "sha" && get.color(card) == "red") return Infinity;
        }
      },
      trigger: { player: "useCard" },
      filter: function(event, player) {
        return event.card.name == "sha" && get.color(event.card) == "red";
      },
      forced: true,
      content: function() {
        if (player.stat[player.stat.length - 1].card.sha > 0) {
          player.stat[player.stat.length - 1].card.sha--;
        }
      },
      group: "poyue2"
    },
    poyue2: {
      trigger: { player: "shaBegin" },
      forced: true,
      popup: false,
      filter: function(event, player) {
        return event.card && get.color(event.card) == "red";
      },
      content: function() {
        trigger.directHit = true;
      }
    },
    jianji: {
      enable: "phaseUse",
      filter: function(event, player) {
        return player.num("he", { type: "equip" }) > 0 && lib.filter.cardEnabled({ name: "sha" }, player);
      },
      usable: 1,
      filterCard: { type: "equip" },
      position: "he",
      check: function(card) {
        var player = _status.currentPhase;
        if (player.num("he", { subtype: get.subtype(card) }) > 1) {
          return 11 - ai.get.equipValue(card);
        }
        return 6 - ai.get.equipValue(card);
      },
      discard: false,
      prepare: function(cards, player) {
        player.$throw(cards);
      },
      delay: false,
      filterTarget: function(card, player, target) {
        return lib.filter.targetEnabled({ name: "sha" }, player, target);
      },
      content: function() {
        "step 0";
        if (!player.skills.contains("unequip")) {
          event.added = true;
          player.skills.push("unequip");
        }
        player.draw();
        player.useCard({ name: "sha" }, cards, targets, "jianji", false).animate = false;
        "step 1";
        if (event.added) {
          player.skills.remove("unequip");
        }
      },
      ai: {
        order: function() {
          return lib.card.sha.ai.order + 0.1;
        },
        result: {
          target: function(player, target) {
            var added = false;
            if (!player.skills.contains("unequip")) {
              added = true;
              player.skills.push("unequip");
            }
            var eff = ai.get.effect(target, { name: "sha" }, player, target);
            if (added) {
              player.skills.remove("unequip");
            }
            return eff;
          }
        },
        effect: {
          player: function(card, player) {
            if (_status.currentPhase != player) return;
            if (get.type(card) == "equip" &&
              player.num("e", { subtype: get.subtype(card) }) &&
              lib.filter.filterCard({ name: "sha" }, player)) {
              return 0;
            }
          }
        },
        threaten: 1.3
      }
    },
    huangyu: {
      enable: "phaseUse",
      filter: function(event, player) {
        return !player.getStat("skill").huangyu && player.num("he", { color: "red" }) > 1;
      },
      filterCard: { color: "red" },
      selectCard: 2,
      position: "he",
      viewAs: { name: "chiyuxi", nature: "fire" },
      check: function(card) {
        var player = _status.event.player;
        if (player.skills.contains("jianji") && get.type(card) == "equip" &&
          lib.filter.filterCard({ name: "sha" }, player)) {
          return 0;
        }
        return 6 - ai.get.value(card);
      },
      ai: {
        order: 8,
        expose: 0.2,
        threaten: 1.2
      }
    },
    gongshen: {
      trigger: { global: "useCard" },
      priority: 15,
      filter: function(event, player) {
        var type = get.type(event.card, "trick");
        if (type != "basic" && type != "trick") return false;
        return event.player != player && player.num("he", { type: "equip" }) > 0 &&
          event.targets && event.targets.length > 0;
      },
      direct: true,
      content: function() {
        "step 0";
        var effect = 0;
        for (var i = 0; i < trigger.targets.length; i++) {
          effect += ai.get.effect(trigger.targets[i], trigger.card, trigger.player, player);
        }
        var str = "是否弃置一张装备牌令" + get.translation(trigger.player);
        if (trigger.targets && trigger.targets.length) {
          str += "对" + get.translation(trigger.targets);
        }
        str += "的" + get.translation(trigger.card) + "失效？";
        player.chooseToDiscard("he", { type: "equip" }, str).ai = function(card) {
          if (effect < 0) {
            var val = 9 - ai.get.value(card);
            var nme = trigger.card.name;
            if (nme == "tao") return val;
            if (nme == "shunshou" && player == trigger.targets[0]) return val;
            if (nme == "liuxinghuoyu") return val;
            if (nme == "nanman") return val;
            if (nme == "wanjian") return val;
            if (nme == "jingleishan") return val;
            if (nme == "chiyuxi") return val;
            if ((nme == "juedou") && (player == trigger.targets[0] || trigger.targets[0].hp == 1)) return val;
            if (nme == "chenhuodajie") return val;
            if (nme == "lebu" && trigger.targets[0].num("h") > trigger.targets[0].hp) return val;
            if (nme == "sha" && trigger.targets[0].hp == 1 && !trigger.targets[0].num("h", "shan")) return val;
            if (nme == "jiedao" && trigger.targets[0] == player) return val;
            if (nme == "yihuajiemu" && trigger.targets[0] == player) return val;
            if (nme == "shuiyanqijun" && trigger.targets.contains(player)) return val;
            return 0;
          }
          return -1;
        };
        "step 1";
        if (result.bool) {
          game.delay();
          trigger.untrigger();
          trigger.finish();
          player.logSkill("gongshen");
        }
      },
      ai: {
        effect: {
          player: function(card, player, target) {
            if (player != target) return;
            if (get.type(card) == "equip" && player.num("h") <= player.hp) {
              return [0, 0, 0, 0];
            }
          }
        },
        threaten: 2,
        expose: 0.3
      }
    },
    xiaozhan: {
      trigger: { global: "useCard" },
      priority: 15,
      filter: function(event, player) {
        return event.card.name == "sha" && event.player != player &&
          player.num("h", "sha") > 0 && event.targets.contains(player) == false;
      },
      direct: true,
      content: function() {
        "step 0";
        var effect = 0;
        for (var i = 0; i < trigger.targets.length; i++) {
          effect += ai.get.effect(trigger.targets[i], trigger.card, trigger.player, player);
        }
        var str = "是否弃置一张杀令" + get.translation(trigger.player);
        if (trigger.targets && trigger.targets.length) {
          str += "对" + get.translation(trigger.targets);
        }
        str += "的" + get.translation(trigger.card) + "失效？";
        player.chooseToDiscard("h", { name: "sha" }, str).ai = function(card) {
          if (effect < 0) {
            return 9 - ai.get.value(card);
          }
          return -1;
        };
        "step 1";
        if (result.bool) {
          trigger.untrigger();
          trigger.finish();
          player.logSkill("xiaozhan");
        }
      },
      ai: {
        threaten: 1.2,
        expose: 0.1
      }
    },
    chuanyue: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      selectCard: 2,
      filterCard: true,
      discard: false,
      prepare: function(cards, player, targets) {
        player.$throw(cards);
      },
      filterTarget: function(card, player, target) {
        return lib.filter.targetEnabled({ name: "juedou" }, player, target);
      },
      check: function(card) {
        return Math.max(7 - ai.get.value(card), 7 - ai.get.useful(card));
      },
      content: function() {
        player.useCard({ name: "juedou" }, targets, cards).animate = false;
      },
      ai: {
        result: {
          target: function(player, target) {
            return ai.get.effect(target, { name: "juedou" }, player, target);
          }
        },
        order: 8
      }
    },
    yiesheng: {
      enable: "phaseUse",
      filterCard: { color: "black" },
      filter: function(event, player) {
        return player.num("h", { color: "black" }) > 0;
      },
      selectCard: [1, Infinity],
      prompt: "弃置任意张黑色手牌并摸等量的牌",
      check: function(card) {
        return 5 - ai.get.value(card);
      },
      content: function() {
        player.draw(cards.length);
      },
      ai: {
        order: 1,
        result: {
          player: 1
        }
      }
    },
    dangping: {
      trigger: { source: "damageAfter" },
      direct: true,
      filter: function(event, player) {
        return event.parent.name != "dangping" && !player.skills.contains("dangping2");
      },
      content: function() {
        "step 0";
        var next = player.chooseCardTarget({
          position: "he",
          filterTarget: function(card, player, target) {
            return player != target && trigger.player != target && get.distance(trigger.player, target) <= 1;
          },
          filterCard: true,
          ai1: function(card) {
            return ai.get.unuseful(card) + 9;
          },
          ai2: function(target) {
            return ai.get.damageEffect(target, player, player);
          },
          prompt: "是否发动【荡平】？"
        });
        "step 1";
        if (result.bool) {
          player.discard(result.cards);
          player.logSkill("dangping", result.targets);
          player.addTempSkill("dangping2", "phaseAfter");
        }
        "step 2";
        if (result.bool) {
          result.targets[0].damage();
        }
      }
    },
    dangping2: {},
    duishi: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      filterTarget: function(card, player, target) {
        return player != target && target.num("he");
      },
      filterCard: true,
      check: function(card) {
        return 8 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        var suit = get.suit(cards[0]);
        target.chooseToDiscard({ suit: suit }, "弃置一张" + get.translation(suit) +
          "牌，或令" + get.translation(player) + "获得你的一张牌").ai = function(card) {
          if (ai.get.attitude(target, player) > 0) {
            return -1;
          }
          return 11 - ai.get.value(card);
        };

        "step 1";
        if (!result.bool) {
          if (target.num("he")) {
            player.gainPlayerCard(target, "he", true, ai.get.buttonValue);
          }
        }
      },
      ai: {
        order: 9,
        threaten: 1.5,
        result: {
          target: -2,
          player: 0.5
        },
        expose: 0.2
      }
    },
    guisi: {
      trigger: { target: "shaBefore" },
      popup: false,
      direct: true,
      filter: function(event, player) {
        return player.num("h");
      },
      content: function() {
        "step 0";
        player.chooseCard("是否交给" + get.translation(trigger.player) + "一张牌并取消此杀？").ai = function(card) {
          if (ai.get.attitude(player, trigger.player) > 0) {
            return 9 - ai.get.value(card);
          }
          if (player.num("h", { name: "shan" })) return -1;
          return 7 - ai.get.value(card);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("guisi");
          trigger.player.gain(result.cards);
          player.$give(result.cards, trigger.player);
          trigger.untrigger();
          trigger.finish();
        }
      }
    },
    lianwu: {
      mod: {
        selectTarget: function(card, player, range) {
          if (card.name == "sha" && range[1] != -1) range[1]++;
        }
      },
      trigger: { player: "shaBegin" },
      forced: true,
      filter: function(event, player) {
        return event.card && get.color(event.card) == "red";
      },
      content: function() {
        trigger.directHit = true;
      }
    },
    mingfu: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("he", { suit: "club" }) > 0;
      },
      position: "he",
      filterCard: { suit: "club" },
      discard: false,
      prepare: function(cards, player, targets) {
        player.$throw(cards);
      },
      filterTarget: function(card, player, target) {
        return lib.filter.targetEnabled({ name: "guiyoujie" }, player, target);
      },
      check: function(card) {
        return Math.max(7 - ai.get.value(card), 7 - ai.get.useful(card));
      },
      content: function() {
        target.addJudge("guiyoujie", cards);
      },
      ai: {
        result: {
          target: function(player, target) {
            return ai.get.effect(target, { name: "guiyoujie" }, player, target);
          }
        },
        order: 8
      }
    },
    mufeng: {
      priority: 9,
      // mod:{
      // 	globalTo:function(from,to,distance){
      // 		return distance+1;
      // 	}
      // },
      filter: function(event, player) {
        return event.player != player && get.type(event.card) == "trick" && event.targets && event.targets.length > 1;
      },
      check: function(event, player) {
        return get.tag(event.card, "multineg") || ai.get.effect(player, event.card, event.player, player) <= 0;
      },
      trigger: { target: "useCardToBefore" },
      content: function() {
        trigger.untrigger();
        trigger.finish();
        player.draw();
      },
      ai: {
        effect: {
          target: function(card) {
            if (card.name == "tiesuo") return [0, 0];
            if (card.name == "yihuajiemu") return [0, 1];
            if (get.tag(card, "multineg")) return [0, 2];
          }
        }
      }
    },
    jiying: {
      // trigger:{player:'respond'},
      // filter:function(event,player){
      // 	return event.card.name=='shan'&&
      // 		player.num('h','sha')>0&&_status.currentPhase!=player;
      // },
      // direct:true,
      // content:function(){
      // 	player.chooseToUse('是否发动【疾鹰】？',{name:'sha'});
      // },
      mod: {
        targetInRange: function(card) {
          if (card.name == "sha") return true;
        }
      }
      // ai:{
      // 	effect:{
      // 		target:function(card,player,target,current){
      // 			if(get.tag(card,'respondShan')&&target.num('h')) return 0.8;
      // 		}
      // 	}
      // }
    },
    minjing: {
      trigger: { player: "damageBegin" },
      forced: true,
      filter: function(event, player) {
        if (player.get("e", "2")) return false;
        if (event.source && event.source.num("s", "unequip")) return;
        if (Math.random() > 1 / 3) return false;
        return true;
      },
      content: function() {
        trigger.num--;
      },
      ai: {
        threaten: 0.8
      }
    },
    touxi: {
      trigger: { global: "phaseEnd" },
      check: function(event, player) {
        return ai.get.damageEffect(event.player, player, player, "thunder") > 0;
      },
      filter: function(event, player) {
        return event.player != player && !player.skills.contains("touxi2");
      },
      content: function() {
        "step 0";
        player.line(trigger.player, "thunder");
        player.judge(function(card) {
          if (get.color(card) == "black") return 1;
          return -1;
        });
        "step 1";
        if (result.bool) {
          trigger.player.damage("thunder");
          player.draw();
          player.addSkill("touxi2");
          event.finish();
        } else {
          if (player.num("he")) {
            trigger.player.discardPlayerCard(player, "he", true, ai.get.buttonValue);
          }
        }
      },
      ai: {
        expose: 0.3,
        threaten: 1.2
      }
    },
    touxi2: {
      trigger: { player: "phaseBegin" },
      forced: true,
      popup: false,
      content: function() {
        player.removeSkill("touxi2");
      }
    },
    lianji: {
      enable: "phaseUse",
      usable: 1,
      filterTarget: function(card, player, target) {
        if (player == target) return false;
        return target.num("h") > 0;
      },
      selectTarget: 2,
      multitarget: true,
      multiline: true,
      prepare: function(cards, player, targets) {
        player.$throw(cards);
        player.line(targets);
      },
      discard: false,
      filterCard: true,
      check: function(card) {
        return 6 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        if (!player.storage.lianji) {
          player.storage.lianji = [];
        }
        if (targets[0].num("h") && targets[1].num("h")) {
          targets[0].chooseToCompare(targets[1]);
          player.storage.lianji.add(targets[0]);
          player.storage.lianji.add(targets[1]);
        } else {
          event.finish();
        }
        "step 1";
        if (result.bool) {
          targets[0].gain(cards);
          targets[0].$gain2(cards);
          targets[1].damage(targets[0]);
        } else {
          targets[1].gain(cards);
          targets[1].$gain2(cards);
          targets[0].damage(targets[1]);
        }
        if (!player.skills.contains("yinmo")) {
          event.finish();
        }
        "step 2";
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i] != player && !player.storage.lianji.contains(game.players[i])) {
            event.finish();
            return;
          }
        }
        "step 3";
        player.logSkill("yinmo");
        player.gainMaxHp();
        "step 4";
        lib.character.swd_duguningke2 = ["", "qun", 4, ["benlei", "juece"], ["temp"]];
        if (player.name == "swd_duguningke") player.name = "swd_duguningke2";
        if (player.name1 == "swd_duguningke") player.name1 = "swd_duguningke2";
        if (player.name2 == "swd_duguningke") {
          player.name2 = "swd_duguningke2";
          player.node.avatar2.setBackground("swd_duguningke2", "character");
        } else {
          player.node.avatar.setBackground("swd_duguningke2", "character");
        }
        player.removeSkill("yinmo");
        player.removeSkill("lianji");
        player.removeSkill("touxi");
        player.addSkill("benlei");
        player.addSkill("juece");
        event.players = game.players.slice(0);
        event.players.remove(player);
        event.players.sort(lib.sort.seat);
        "step 5";
        if (event.players.length) {
          event.players.shift().damage("thunder");
          event.redo();
        }
      },
      ai: {
        expose: 0.3,
        threaten: 2,
        order: 9,
        result: {
          target: -1
        }
      }
    },
    lianji2: {
      group: ["lianji3", "lianji4"]
    },
    lianji3: {
      trigger: { player: "shaHit" },
      forced: true,
      popup: false,
      content: function() {
        player.storage.lianji2 = true;
      }
    },
    lianji4: {
      trigger: { player: "shaAfter" },
      forced: true,
      popup: false,
      content: function() {
        if (!player.storage.lianji2) {
          player.damage("thunder", player.storage.lianji);
        }
        delete player.storage.lianji;
        delete player.storage.lianji2;
        player.removeSkill("lianji2");
      }
    },
    yinmo: {},
    miedao: {
      group: ["miedao1", "miedao2"],
      ai: {
        threaten: 1.4
      }
    },
    miedao1: {
      trigger: { player: "phaseDrawBegin" },
      forced: true,
      filter: function(event, player) {
        return player.hp < player.maxHp;
      },
      content: function() {
        trigger.num += player.maxHp - player.hp;
      }
    },
    miedao2: {
      trigger: { player: "phaseDiscardBegin" },
      forced: true,
      filter: function(event, player) {
        return player.hp < player.maxHp;
      },
      content: function() {
        player.chooseToDiscard(player.maxHp - player.hp, "he", true);
      }
    },
    milesxiehun: {
      trigger: { player: "phaseEnd" },
      forced: true,
      content: function() {
        "step 0";
        event.num = 0;
        event.targets = game.players.slice(0);
        event.targets.remove(player);
        for (var i = 0; i < event.targets.length; i++) {
          event.targets.sort(lib.sort.random);
        }
        event.targets.splice(Math.max(1, player.maxHp - player.hp));
        //event.targets.unshift(player);
        "step 1";
        if (event.num < event.targets.length) {
          var target = event.targets[event.num];
          target.discard(target.get("he").randomGet());
          event.num++;
          event.redo();
        }
      }
    },
    liaochen: {
      trigger: { player: "phaseEnd" },
      forced: true,
      content: function() {
        "step 0";
        event.num = 0;
        event.targets = game.players.slice(0);
        "step 1";
        if (event.num < event.targets.length) {
          if (event.targets[event.num].num("he")) {
            event.targets[event.num].chooseToDiscard(true, "he");
          }
          event.num++;
          event.redo();
        }
      }
    },
    aojian: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.hp < player.maxHp;
      },
      filterTarget: function(card, player, target) {
        return player != target && get.distance(player, target, "attack") <= 1;
      },
      selectTarget: function() {
        return ui.selected.cards.length;
      },
      selectCard: function() {
        var player = _status.currentPhase;
        return [1, Math.min(game.players.length - 1, player.maxHp - player.hp)];
      },
      filterCard: true,
      check: function(card) {
        if (ui.selected.cards.length == 0) {
          return 8 - ai.get.value(card);
        }
        return 5 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        target.damage();
        "step 1";
        // target.draw();
      },
      ai: {
        order: 9,
        result: {
          target: function(player, target) {
            return ai.get.damageEffect(target, player, target);
          }
        },
        threaten: function(player, target) {
          if (target.hp == 1) return 2;
          if (target.hp == 2) return 1.5;
          return 0.5;
        },
        maixie: true,
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              if (target.hp == target.maxHp) return [0, 1];
            }
            if (get.tag(card, "recover") && player.hp >= player.maxHp - 1) return [0, 0];
          }
        }
      }
    },
    moyan: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.hp < player.maxHp && player.num("h", { color: "red" }) > 0;
      },
      filterTarget: function(card, player, target) {
        return player != target;//&&get.distance(player,target,'attack')<=1;
      },
      selectTarget: function() {
        return ui.selected.cards.length;
      },
      selectCard: function() {
        var player = _status.currentPhase;
        return [1, Math.min(game.players.length - 1, player.maxHp - player.hp)];
      },
      filterCard: function(card) {
        return get.color(card) == "red";
      },
      check: function(card) {
        if (ui.selected.cards.length == 0) {
          return 8 - ai.get.value(card);
        }
        return 6 - ai.get.value(card);
      },
      line: "fire",
      content: function() {
        "step 0";
        target.damage("fire");
        "step 1";
        // target.draw();
      },
      ai: {
        order: 9,
        result: {
          target: function(player, target) {
            return ai.get.damageEffect(target, player, target, "fire");
          }
        },
        threaten: function(player, target) {
          if (target.hp == 1) return 2;
          if (target.hp == 2) return 1.5;
          return 0.5;
        },
        maixie: true,
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              if (target.hp == target.maxHp) return [0, 1];
            }
            if (get.tag(card, "recover") && player.hp >= player.maxHp - 1) return [0, 0];
          }
        }
      }
    },
    shejie: {
      trigger: { player: "damageEnd" },
      priority: 9,
      check: function(event, player) {
        return ai.get.attitude(player, event.source) < 0;
      },
      filter: function(event) {
        return event && event.source;
      },
      content: function() {
        trigger.source.addSkill("shejie2");
      },
      ai: {
        threaten: 0.4
      }
    },
    shejie2: {
      unique: true,
      trigger: { player: "phaseBegin" },
      forced: true,
      priority: 10,
      mod: {
        cardEnabled: function() {
          return false;
        },
        cardUsable: function() {
          return false;
        },
        cardRespondable: function() {
          return false;
        },
        cardSavable: function() {
          return false;
        }
      },
      content: function() {
        player.removeSkill("shejie2");
      }
    },
    guiyin: {
      trigger: { player: "phaseDiscardEnd" },
      frequent: true,
      filter: function(event, player) {
        return event.cards && event.cards.length > 1;
      },
      content: function() {
        player.draw(2);
      }
    },
    swdqinyin: {
      trigger: { player: "phaseEnd" },
      direct: true,
      filter: function(event, player) {
        return !player.getStat("damage");
      },
      content: function() {
        "step 0";
        var recover = 0, lose = 0;
        for (var i = 0; i < game.players.length; i++) {
          if (!game.players[i].isOut()) {
            if (game.players[i].hp < game.players[i].maxHp) {
              if (ai.get.attitude(player, game.players[i]) > 0) {
                if (game.players[i].hp < 2) {
                  lose--;
                  recover += 0.5;
                }
                lose--;
                recover++;
              } else if (ai.get.attitude(player, game.players[i]) < 0) {
                if (game.players[i].hp < 2) {
                  lose++;
                  recover -= 0.5;
                }
                lose++;
                recover--;
              }
            } else {
              if (ai.get.attitude(player, game.players[i]) > 0) {
                lose--;
              } else if (ai.get.attitude(player, game.players[i]) < 0) {
                lose++;
              }
            }
          }
        }
        player.chooseControl("失去体力", "回复体力", "cancel").ai = function() {
          // console.log(lose,recover);
          if (lose > recover && lose > 0) return 0;
          if (lose < recover && recover > 0) return 1;
          return 2;
        };
        "step 1";
        if (result.bool == false || result.control == "cancel") {
          event.finish();
        } else {
          player.logSkill("swdqinyin");
          event.bool = (result.control == "回复体力");
          event.num = 0;
          event.players = game.players.slice(0);
        }
        "step 2";
        if (event.num < event.players.length) {
          var target = event.players[event.num];
          if (event.bool) {
            target.recover();
          } else {
            target.loseHp();
          }
          event.num++;
          event.redo();
        }
      },
      ai: {
        expose: 0.1,
        threaten: 2
      }
    },
    wangchen: {
      trigger: { player: "phaseDiscardEnd" },
      direct: true,
      filter: function(event, player) {
        if (event.cards) {
          for (var i = 0; i < event.cards.length; i++) {
            if (get.type(event.cards[i]) == "basic") return true;
          }
        }
        return false;
      },
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【忘尘】？").ai = function(target) {
          return ai.get.attitude(player, target) * (target.isTurnedOver() ? 1 : -1);
        };
        "step 1";
        if (result.bool) {
          var target = result.targets[0];
          player.logSkill("wangchen", target);
          target.turnOver();
        }
      },
      ai: {
        expose: 0.5,
        threaten: 2
      }
    },
    wangchen2: {
      trigger: { player: "phaseBefore" },
      forced: true,
      popup: false,
      filter: function(event, player) {
        var prev = player.previous;
        if (prev.storage.wangchen == prev) {
          return true;
        }
      },
      content: function() {
        player.previous.out();
      }
    },
    wangchen3: {
      trigger: { player: "dieBegin" },
      forced: true,
      popup: false,
      filter: function(event, player) {
        return player.storage.wangchen && player.storage.wangchen.isOut();
      },
      content: function() {
        player.storage.wangchen.out();
      }
    },
    tiandao: {
      trigger: { global: "judge" },
      direct: true,
      filter: function(event, player) {
        return player.num("he") > 0;
      },
      content: function() {
        "step 0";
        player.chooseCard("请选择替换判定的牌", "he").ai = function(card) {
          var trigger = _status.event.parent._trigger;
          var player = _status.event.player;
          var result = trigger.judge(card) - trigger.judge(trigger.player.judging);
          var attitude = ai.get.attitude(player, trigger.player);
          if (attitude == 0 || result == 0) return 0;
          if (attitude > 0) {
            return result;
          } else {
            return -result;
          }
        };
        "step 1";
        if (result.bool) {
          player.respond(result.cards);
        } else {
          event.finish();
        }
        "step 2";
        if (result.bool) {
          player.logSkill("tiandao");
          player.$gain2(trigger.player.judging);
          player.gain(trigger.player.judging);
          trigger.player.judging = result.cards[0];
          trigger.position.appendChild(result.cards[0]);
          game.log(get.translation(trigger.player) + "的判定牌改为" + get.translation(result.cards[0]));
        }
        "step 3";
        game.delay(2);
      },
      ai: {
        tag: {
          rejudge: 1
        },
        threaten: 1.5
      }
    },
    yihua: {
      trigger: { target: "useCardToBefore" },
      popup: false,
      direct: true,
      filter: function(event, player) {
        // return event.card&&get.color(event.card)=='red'&&event.player!=player;
        return event.targets.length == 1 && event.player != player && player.num("h") >= 2;
      },
      content: function() {
        "step 0";
        player.chooseToDiscard("是否弃置两张手牌将" + get.translation(trigger.card) + "反弹？", 2).ai = function(card) {
          if (ai.get.effect(player, trigger.card) < 0) return 4 - ai.get.value(card);
          return 0;
        };
        "step 1";
        if (result.bool) {
          // player.discard(result.cards);
          player.logSkill("yihua");
          trigger.target = trigger.player;
          trigger.player = player;
          trigger.untrigger();
          trigger.trigger("useCardToBefore");
        }
        // "step 2"
        // if(result.bool){
        // 	trigger.target=result.targets[0];
        // 	trigger.untrigger;
        // 	trigger.trigger('shaBefore');
        // 	game.delay();
        // }
      },
      ai: {
        threaten: function(player, target) {
          if (target.num("h") <= 2) {
            return 2;
          }
          return 2 / (target.num("h") - 1);
        }
      }
    },
    youyin: {
      trigger: { global: "discardAfter" },
      filter: function(event, player) {
        if (event.player == player) return false;
        if (player.num("h") >= 5) return false;
        for (var i = 0; i < event.cards.length; i++) {
          if (get.type(event.cards[i]) != "basic") {
            return true;
          }
        }
        return false;
      },
      frequent: true,
      content: function() {
        "step 0";
        if (trigger.delay == false) game.delay();
        "step 1";
        player.draw();
      }
    },
    fushen: {
      trigger: { player: "phaseBefore" },
      check: function() {
        return false;
      },
      direct: true,
      filter: function(event, player) {
        return !player.phaseSkipped;
      },
      content: function() {
        "step 0";
        player.chooseTarget(function(card, player, target) {
          if (player == target) return false;
          return true;
        }, "是否发动附身？").ai = function() {
          return -1;//1+Math.random();
        };
        "step 1";
        if (result.bool) {
          var target = result.targets[0];
          event.target = target;
          target.storage.fushen = player;
          game.swapPlayer(target);
          // player.out();
          // player.lockOut=true;
          // trigger.untrigger();
          // trigger.finish();
          // target.phase();
          // target.addSkill('fushen2');
          trigger.untrigger();
          trigger.finish();
        } else {
          event.finish();
        }
        "step 2";
        player.out();
        player.lockOut = true;
        if (player.ai.shown < 0.5) {
          player.ai.shown = 0.5;
        }
        // trigger.untrigger();
        // trigger.finish();
        // target.phase();
        event.target.addSkill("fushen2");
        event.target.storage.fushen2 = event.target.ai.shown;
        event.target.phase();
      },
      ai: {
        threaten: 1.5
      }
    },
    fushen2: {
      trigger: { player: "phaseAfter" },
      forced: true,
      popup: false,
      content: function() {
        var source = player.storage.fushen;
        player.ai.shown = player.storage.fushen2;
        delete player.storage.fushen;
        delete player.storage.fushen2;
        if (source) {
          source.lockOut = false;
          source.out();
          game.swapPlayer(source);
          source.loseHp();
          player.removeSkill("fushen2");
        }
        // source.skip('phase');
      }
    },
    anlianying: {
      trigger: { player: "loseEnd" },
      frequent: true,
      filter: function(event, player) {
        if (player.num("h")) return false;
        for (var i = 0; i < event.cards.length; i++) {
          if (event.cards[i].original == "h") return true;
        }
        return false;
      },
      content: function() {
        player.draw(2);
      },
      ai: {
        effect: {
          target: function(card) {
            if (card.name == "guohe" || card.name == "liuxinghuoyu") return 0.5;
          }
        }
      }
    },
    miejing: {
      forbid: ["infinity"],
      init: function(player) {
        player.storage.miejing = false;
      },
      enable: "phaseUse",
      filter: function(event, player) {
        //if(player.maxHp<=1) return false;
        return !player.storage.miejing;
      },
      intro: {
        content: "limited"
      },
      content: function() {
        "step 0";
        var cards = player.get("hej");
        for (var i = 0; i < cards.length; i++) {
          if (get.color(cards[i]) != "black") {
            cards.splice(i, 1);
            i--;
          }
        }
        cards.sort(lib.sort.random);
        player.discard(cards);
        event.num = 0;
        event.players = game.players.slice(0);
        player.storage.miejing = true;
        "step 1";
        var i = event.num;
        if (event.num < event.players.length) {
          if (event.players[event.num] != player) {
            event.players[i].damage("thunder", "nosource");
          }
          event.num++;
          event.redo();
        }
        //player.maxHp=1;
        //player.update();
      }
    },
    // zhanlu:{
    // 	enable:'phaseUse',
    // 	filterCard:function(card){
    // 		return get.suit(card)=='heart';
    // 	},
    // 	position:'he',
    // 	viewAs:{name:'taoyuan'},
    // 	prompt:'将一张红桃牌当作桃园结义使用',
    // 	check:function(card){return 6-ai.get.value(card)},
    // 	ai:{
    // 		threaten:1.2
    // 	}
    // },
    zhanlu: {
      enable: "phaseUse",
      filterCard: function(card) {
        var suit = get.suit(card);
        return suit == "spade";
      },
      position: "he",
      usable: 1,
      check: function(card) {
        return 10 - ai.get.value(card);
      },
      filterTarget: function(card, player, target) {
        if (target.hp >= target.maxHp) return false;
        return true;
      },
      selectTarget: [1, 3],
      content: function() {
        target.recover();
      },
      ai: {
        order: 10,
        result: {
          target: function(player, target) {
            if (player == target && player.num("h") > player.hp) return 20;
            return ai.get.recoverEffect(target, player, target);
          }
        },
        threaten: 2
      }
    },
    huopu: {
      enable: "phaseUse",
      filterCard: function(card) {
        return get.suit(card) == "heart";
      },
      viewAs: { name: "liuxinghuoyu" },
      prompt: "将一张红桃手牌当作流星火羽使用",
      check: function(card) {
        return 6 - ai.get.value(card);
      },
      ai: {
        threaten: 1.4
      }
    },
    rexue: {
      trigger: { global: "phaseBegin" },
      direct: true,
      filter: function(event, player) {
        return lib.filter.targetEnabled({ name: "sha" }, player, event.player) && !lib.filter.autoRespondSha.call({ player: player });
      },
      content: function() {
        "step 0";
        player.chooseToUse({ name: "sha" }, "是否对" + get.translation(trigger.player) + "使用一张杀", trigger.player);
        "step 1";
        if (result.bool) {
          player.logSkill("rexue");
          player.draw();
        }
      }
    },
    shengshou: {
      enable: "phaseUse",
      filterCard: function(card) {
        return get.color(card) == "black";
      },
      viewAs: { name: "caoyao" },
      prompt: "将一张黑色手牌当作草药使用",
      check: function(card) {
        return 6 - ai.get.value(card);
      },
      ai: {
        threaten: 1.6
      }
    },
    huanjian: {
      enable: "phaseUse",
      filterCard: function(card) {
        return get.color(card) == "black";
      },
      viewAs: { name: "dujian" },
      prompt: "将一张黑色手牌当作毒箭使用",
      check: function(card) {
        return 5 - ai.get.value(card);
      },
      ai: {
        threaten: 1.6
      }
    },
    benlei: {
      enable: "phaseUse",
      viewAs: { name: "jingleishan", nature: "thunder" },
      filterCard: function(card, player) {
        return true;
      },
      selectCard: 3,
      position: "he",
      prompt: "将三张牌当作惊雷闪使用",
      check: function(card) {
        return 4 - ai.get.value(card);
      },
      group: "benlei2",
      ai: {
        basic: {
          order: 10
        }
      }
    },
    benlei2: {
      trigger: { source: "damageAfter" },
      filter: function(event, player) {
        return event.nature == "thunder" && player.hp < player.maxHp;
      },
      forced: true,
      content: function() {
        player.recover();
      }
    },
    moyu: {
      trigger: { source: "dieAfter" },
      filter: function(event, player) {
        return player.hp < player.maxHp;
      },
      frequent: true,
      content: function() {
        player.recover(player.maxHp - player.hp);
      },
      threaten: 1.2
    },
    susheng: {
      trigger: { global: "dieBefore" },
      direct: true,
      check: function(event, player) {
        return player.attitudeTo(event.player) > 3;
      },
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      content: function() {
        "step 0";
        player.chooseToDiscard("是否发动苏生？").ai = ai.get.unuseful2;
        "step 1";
        if (result.bool) {
          // player.chooseToDiscard('h',true);
          trigger.untrigger();
          trigger.finish();
          trigger.player.hp = 1;
          if (trigger.player.maxHp < 1) trigger.player.maxHp = 1;
          trigger.player.update();
          player.logSkill("susheng");
        }

      },
      ai: {
        threaten: 2
      }
    },
    kunlunjing: {
      unique: true,
      group: ["kunlunjing1", "kunlunjing2"],
      intro: {
        content: function(storage, player) {
          return player.storage.kunlunjing3;

          for (var i = 0; i < storage.length; i++) {
            if (game.players.contains(storage[i].player)) {
              st = storage[i];

              tr = document.createElement("tr");
              table.appendChild(tr);
              td = document.createElement("td");
              td.innerHTML = get.translation(st.player);
              tr.appendChild(td);
              td = document.createElement("td");
              td.innerHTML = (st.handcards1.length + st.handcards2.length);
              td.style.textAlign = "center";
              tr.appendChild(td);

              td = document.createElement("td");
              td.style.width = "30px";
              tr.appendChild(td);

              str = "";
              if (st.equips.length + st.judges.length) {
                if (st.equips.length) {
                  str += get.translation(st.equips);
                }
                str = get.translation(st.equips.concat(st.judges));
              } else {
                str = "无";
              }
              td = document.createElement("td");
              td.innerHTML = str;
              tr.appendChild(td);
            }
          }

          player.storage.kunlunjing3 = table.outerHTML;
          return table.outerHTML;
        }
      }
    },
    kunlunjing1: {
      trigger: { player: ["damageAfter", "phaseBefore"] },
      filter: function(event, player) {
        if (player.storage.kunlunjing2) return false;
        if (player.storage.kunlunjing) return true;
        return false;
      },
      check: function(event, player) {
        if (event.name == "phase" && player.hp < 3) return false;
        var storage = event.player.storage.kunlunjing;
        var num = 0;
        for (i = 0; i < storage.length; i++) {
          if (game.players.contains(storage[i].player)) {
            var att = ai.get.attitude(player, storage[i].player);
            var num2 = storage[i].value - storage[i].player.num("he") + storage[i].player.num("j");
            // console.log(storage[i].player.name,storage[i].value,storage[i].player.num('he')-storage[i].player.num('j'))
            if (att > 0) {
              num += num2;
            } else if (att < 0) {
              num -= num2;
            }
          }
        }
        return num > Math.min(3, game.players.length);
      },
      content: function() {
        "step 0";
        event.player.storage.kunlunjing2 = true;
        ui.arena.classList.add("zoomout3");
        ui.arena.delete();
        ui.arena.hide();
        game.delay(0, 500);
        "step 1";
        var storage = event.player.storage.kunlunjing;
        var player, frag;
        var i, j;
        for (i = 0; i < storage.length; i++) {
          if (game.players.contains(storage[i].player)) {
            player = storage[i].player;
            while (player.node.handcards1.childNodes.length)
              ui.discardPile.appendChild(player.node.handcards1.firstChild);

            while (player.node.handcards2.childNodes.length)
              ui.discardPile.appendChild(player.node.handcards2.firstChild);

            while (player.node.judges.childNodes.length)
              ui.discardPile.appendChild(player.node.judges.firstChild);

            while (player.node.equips.childNodes.length)
              ui.discardPile.appendChild(player.node.equips.firstChild);
          }
        }
        for (i = 0; i < storage.length; i++) {
          if (game.players.contains(storage[i].player)) {
            player = storage[i].player;
            for (j = 0; j < storage[i].handcards1.length; j++) {
              if (storage[i].handcards1[j].parentNode == ui.discardPile ||
                storage[i].handcards1[j].parentNode == ui.cardPile)
                player.node.handcards1.appendChild(storage[i].handcards1[j]);
            }
            for (j = 0; j < storage[i].handcards2.length; j++) {
              if (storage[i].handcards2[j].parentNode == ui.discardPile ||
                storage[i].handcards2[j].parentNode == ui.cardPile)
                player.node.handcards2.appendChild(storage[i].handcards2[j]);
            }
            for (j = 0; j < storage[i].equips.length; j++) {
              if (storage[i].equips[j].parentNode == ui.discardPile ||
                storage[i].equips[j].parentNode == ui.cardPile)
                player.node.equips.appendChild(storage[i].equips[j]);
            }
            for (j = 0; j < storage[i].judges.length; j++) {
              if (storage[i].judges[j].parentNode == ui.discardPile ||
                storage[i].judges[j].parentNode == ui.cardPile) {
                storage[i].judges[j].viewAs = storage[i].viewAs[j];
                player.node.judges.appendChild(storage[i].judges[j]);
              }
            }
            player.update();
          }
        }
        game.delay(0, 100);
        ui.arena.classList.remove("zoomout3");
        ui.arena.classList.add("zoomin3");
        ui.window.appendChild(ui.arena);
        "step 2";
        ui.arena.show();
        ui.arena.classList.remove("zoomin3");
        event.player.storage.kunlunjing3 = "已发动";
        if (trigger.name == "phase") {
          event.player.loseHp();
        }
      }
    },
    kunlunjing2: {
      trigger: { player: "phaseAfter" },
      forced: true,
      popup: false,
      silent: true,
      content: function() {
        var handcards1, handcards2, judges, equips, viewAs, i, j;
        player.storage.kunlunjing = [];
        player.storage.kunlunjing2 = false;

        var table = document.createElement("table");
        var tr, td, str, st;

        for (i = 0; i < game.players.length; i++) {
          viewAs = [];
          handcards1 = [];
          handcards2 = [];
          judges = [];
          equips = [];

          for (j = 0; j < game.players[i].node.handcards1.childNodes.length; j++)
            handcards1.push(game.players[i].node.handcards1.childNodes[j]);

          for (j = 0; j < game.players[i].node.handcards2.childNodes.length; j++)
            handcards2.push(game.players[i].node.handcards2.childNodes[j]);

          for (j = 0; j < game.players[i].node.judges.childNodes.length; j++) {
            viewAs.push(game.players[i].node.judges.childNodes[j].viewAs);
            judges.push(game.players[i].node.judges.childNodes[j]);
          }

          for (j = 0; j < game.players[i].node.equips.childNodes.length; j++)
            equips.push(game.players[i].node.equips.childNodes[j]);

          tr = document.createElement("tr");
          tr.style.verticalAlign = "top";
          table.appendChild(tr);
          td = document.createElement("td");
          td.innerHTML = get.translation(game.players[i]);
          tr.appendChild(td);
          td = document.createElement("td");
          td.innerHTML = (handcards1.length + handcards2.length);
          tr.appendChild(td);

          str = "";
          if (equips.length + judges.length) {
            if (equips.length) {
              str += get.translation(equips);
              if (judges.length) {
                str += "、";
              }
            }
            if (judges.length) {
              str += get.translation(judges, "viewAs");
            }
          } else {
            str = "";
          }
          td = document.createElement("td");
          td.innerHTML = str;
          tr.appendChild(td);

          player.storage.kunlunjing.push({
            player: game.players[i],
            handcards1: handcards1,
            handcards2: handcards2,
            judges: judges,
            equips: equips,
            viewAs: viewAs,
            value: handcards1.length + handcards2.length + equips.length - judges.length
          });
        }
        table.firstChild.firstChild.style.width = "85px";
        table.firstChild.childNodes[1].style.width = "48px";
        player.storage.kunlunjing3 = table.outerHTML;
      }
    },
    swdshelie: {
      trigger: { player: "phaseDrawBefore" },
      content: function() {
        "step 0";
        trigger.untrigger();
        trigger.finish();
        "step 1";
        event.cards = get.cards(5);
        if (event.isMine() == false) {
          event.dialog = ui.create.dialog("涉猎", event.cards);
          game.delay(2);
        }
        "step 2";
        if (event.dialog) event.dialog.close();
        var dialog = ui.create.dialog("涉猎", event.cards);
        player.chooseButton([0, 5], dialog, true).filterButton = function(button) {
          for (var i = 0; i < ui.selected.buttons.length; i++) {
            if (get.suit(button.link) == get.suit(ui.selected.buttons[i].link)) return false;
          }
          return true;
        };
        "step 3";
        var cards2 = [];
        for (var i = 0; i < result.buttons.length; i++) {
          cards2.push(result.buttons[i].link);
          cards.remove(result.buttons[i].link);
        }
        player.gain(cards2);
        if (cards2.length) player.$gain(cards2);
        for (var i = 0; i < cards.length; i++) {
          ui.discardPile.appendChild(cards[i]);
        }
        game.delay(2);
      },
      ai: {
        threaten: 1.2
      }
    },
    oldliaoyuan: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      filterTarget: function(card, player, target) {
        return player != target;
      },
      filterCard: function(card, player) {
        if (ui.selected.cards.length) {
          return get.suit(card) == get.suit(ui.selected.cards[0]);
        }
        var cards = player.get("h");
        for (var i = 0; i < cards.length; i++) {
          if (card != cards[i]) {
            if (get.suit(card) == get.suit(cards[i])) return true;
          }
        }
        return false;
      },
      prepare: function(cards, player, targets) {
        player.$throw(cards);
      },
      // selectTarget:[1,2],
      selectCard: [2, 2],
      check: function(card) {
        return 6 - ai.get.useful(card);
      },
      prompt: "弃置两张相同花色的手牌，选择一名角色弃置其一张牌，并视为对其使用一张火杀",
      content: function() {
        "step 0";
        if (target.num("he")) {
          player.discardPlayerCard(target, "he");
        }
        "step 1";
        player.useCard({ name: "sha", nature: "fire" }, target, false, "oldliaoyuan").animate = false;
      },
      ai: {
        order: 3,
        result: {
          target: function(player, target) {
            return ai.get.effect(target, { name: "sha", nature: "fire" }, player, target) - 1;
          }
        },
        expose: 0.2
      }
    },
    oldliaoyuan2: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      filterTarget: function(card, player, target) {
        return player != target;
      },
      filterCard: function(card, player) {
        if (ui.selected.cards.length) {
          return get.suit(card) == get.suit(ui.selected.cards[0]);
        }
        var cards = player.get("h");
        for (var i = 0; i < cards.length; i++) {
          if (card != cards[i]) {
            if (get.suit(card) == get.suit(cards[i])) return true;
          }
        }
        return false;
      },
      delay: false,
      discard: false,
      selectCard: [2, 2],
      check: function(card) {
        return 7 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        player.useCard({ name: "sha" }, [cards[0]], target, false, "liaoyuan");
        "step 1";
        player.useCard({ name: "sha" }, [cards[1]], target, false, "liaoyuan");
      },
      ai: {
        order: 6,
        result: {
          target: function(player, target) {
            return ai.get.effect(target, { name: "sha" }, player, target) * 2;
          }
        },
        expose: 0.2
      }
    },
    shehun: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      filterTarget: function(card, player, target) {
        return player != target && target.num("he") > 0;
      },
      filterCard: function(card) {
        var suit = get.suit(card);
        for (var i = 0; i < ui.selected.cards.length; i++) {
          if (get.suit(ui.selected.cards[i]) == suit) return false;
        }
        return true;
      },
      selectCard: [1, 4],
      check: function(card) {
        return 7 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        var suits = [];
        event.suits = suits;
        for (var i = 0; i < cards.length; i++) {
          suits.push(get.suit(cards[i]));
        }
        var hs = target.get("he");
        var hss = {
          club: [],
          diamond: [],
          spade: [],
          heart: []
        };
        var choice = [];
        for (var i = 0; i < hs.length; i++) {
          var suity = get.suit(hs[i]);
          if (hss[suity]) {
            hss[suity].push(hs[i]);
          }
        }
        for (var i in hss) {
          if (!suits.contains(i)) {
            choice = choice.concat(hss[i]);
            delete hss[i];
          }
        }
        if (choice.length < cards.length) {
          choice.length = 0;
        }
        target.chooseToDiscard(cards.length, true, "he").ai = function(card) {
          var num = choice.contains(card) ? 20 : 0;
          return num - ai.get.value(card);
        };
        "step 1";
        var damage = false;
        for (var i = 0; i < result.cards.length; i++) {
          if (event.suits.contains(get.suit(result.cards[i]))) {
            damage = true;
            break;
          }
        }
        if (damage) {
          target.damage();
        }
      },
      ai: {
        order: 6,
        result: {
          target: function(player, target) {
            var eff = ai.get.damageEffect(target, player);
            var num = target.num("he");
            var length = ui.selected.cards.length;
            if (num == length) return -2 + eff;
            if (num > length) return -1.5 + eff;
            return -1 + eff;
          }
        },
        expose: 0.2
      }
    },
    liaoyuan: {
      trigger: { player: "shaAfter" },
      direct: true,
      filter: function(event, player) {
        if (get.itemtype(event.cards) != "cards") return false;
        if (player.num("he", { suit: get.suit(event.cards) }) > 0) {
          for (var i = 0; i < event.targets.length; i++) {
            if (event.targets[i].isAlive()) return true;
          }
        }
        return false;
      },
      content: function() {
        "step 0";
        var suit = get.suit(trigger.cards);
        player.chooseCard("he", "是否将一张" + get.translation(suit) + "牌当杀对" +
          get.translation(trigger.targets) + "使用？", { suit: suit }).ai = function(card) {
          var eff = 0;
          for (var i = 0; i < trigger.targets.length; i++) {
            eff += ai.get.effect(trigger.targets[i], { name: "sha" }, player, player);
          }
          if (eff > 0) {
            return 7 - ai.get.value(card);
          }
        };
        "step 1";
        if (result.bool) {
          player.logSkill("liaoyuan");
          if (result.cards[0].name == "sha") {
            player.useCard(result.cards, trigger.targets);
          } else {
            player.useCard({ name: "sha" }, result.cards, trigger.targets);
          }
        }
      }
    },

    dunxing: {
      mod: {
        targetEnabled: function(card, player, target) {
          if (_status.currentPhase == player && target.hp < player.hp) return false;
        }
      }
    },
    qiaoxie: {
      group: ["xiaoji2", "xuanfeng2"],
      ai: {
        effect: {
          target: function(card, player, target, current) {
            if (get.type(card) == "equip") return [1, 3];
          }
        }
      }
    },
    xiaoji2: {
      trigger: { player: "equipEnd" },
      frequent: true,
      //filter:function(event,player){
      //	for(var i=0;i<event.cards.length;i++){
      //		if(event.cards[i].original=='e') return true;
      //	}
      //	return false;
      //},
      content: function() {
        //var num=0;
        //for(var i=0;i<trigger.cards.length;i++){
        //	if(trigger.cards[i].original=='e') num++;
        //}
        player.draw();
      }
      //effect:{
      //	target:function(card,player,target,current){
      //		if(get.type(card)=='equip') return [1,1];
      //	}
      //}
    },
    duanxing: {
      trigger: { player: "equipEnd" },
      direct: true,
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【锻星】？", function(card, player, target) {
          return lib.filter.targetEnabled({ name: "sha" }, player, target);
        }).ai = function(target) {
          return ai.get.effect(target, { name: "sha" }, player);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("duanxing");
          player.useCard({ name: "sha" }, result.targets, false);
        }
      },
      ai: {
        expose: 0.2
      }
    },
    xuanfeng2: {
      trigger: { player: ["loseEnd"] },
      direct: true,
      filter: function(event, player) {
        if (player.equiping) return false;
        for (var i = 0; i < event.cards.length; i++) {
          if (event.cards[i].original == "e") return true;
        }
        return false;
      },
      content: function() {
        "step 0";
        game.delay(0.5);
        player.chooseTarget([1, 1], "请选择巧械的目标", function(card, player, target) {
          if (player == target) return false;
          return target.num("he") > 0;
        }).ai = function(target) {
          return -ai.get.attitude(player, target);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("xuanfeng2", result.targets);
          player.discardPlayerCard(result.targets[0], "he", true);
        }
      }
    },
    meihuo: {
      trigger: { player: ["loseEnd"] },
      direct: true,
      filter: function(event, player) {
        if (player.equiping) return false;
        if (player.num("e")) return false;
        for (var i = 0; i < event.cards.length; i++) {
          if (event.cards[i].original == "e") return true;
        }
        return false;
      },
      content: function() {
        "step 0";
        player.chooseTarget([1, 1], "是否发动【魅惑】", function(card, player, target) {
          if (player == target) return false;
          return target.num("he") > 0;
        }).ai = function(target) {
          var att = ai.get.attitude(player, target);
          if (att <= 0) {
            return 1 - att + (target.num("e") ? 2 : 0);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          event.target = result.targets[0];
          player.logSkill("meihuo", event.target);
          player.choosePlayerCard(event.target, "he", true).ai = function(button) {
            var card = button.link;
            if (get.position(card) == "e") return ai.get.equipValue(card);
            return 5;
          };
        }
        "step 2";
        if (result.bool) {
          if (get.position(result.buttons[0].link) == "e") {
            player.equip(result.buttons[0].link);
          } else {
            player.gain(result.buttons[0].link);
          }
          event.target.$give(1, player);
          game.delay();
        }
      }
    },
    yuhuo: {
      enable: "chooseToUse",
      filter: function(event, player) {
        if (event.type != "dying") return false;
        if (player != _status.dying) return false;
        if (player.storage.yuhuo) return false;
      },
      content: function() {
        player.maxHp--;
        player.hp = player.maxHp;
        player.discard(player.get("hej"));
        if (player.classList.contains("linked")) player.link();
        if (player.classList.contains("turnedover")) player.turnOver();
        player.storage.yuhuo = true;
        // player.addSkill('guanhong');
        // player.addSkill('yishan2');
        player.update();
      },
      ai: {
        result: {
          player: 10
        },
        threaten: function(player, target) {
          if (!target.storage.yuhuo) return 0.8;
        }
      },
      init: function(player) {
        player.storage.yuhuo = false;
      },
      intro: {
        content: "limited"
      }
    },
    yishan: {
      group: "yishan2",
      trigger: { player: "damageEnd" },
      filter: function(event, player) {
        var content = player.storage.yishan;
        for (var i = 0; i < content.length; i++) {
          if (get.owner(content[i]) != player) {
            return true;
          }
        }
        return false;
      },
      init: function(player) {
        player.storage.yishan = [];
      },
      mark: true,
      content: function() {
        for (var i = 0; i < player.storage.yishan.length; i++) {
          if (get.owner(player.storage.yishan[i]) == player) {
            player.storage.yishan.splice(i, 1);
            i--;
          }
        }
        var cards = player.storage.yishan.splice(0, 2);
        player.gain(cards);
        player.$gain2(cards);
      },
      ai: {
        maixie: true,
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              if (player.skills.contains("jueqing")) return [1, -2];
              if (target.storage.yishan.length == 0) return 1.5;
              if (target.storage.yishan[0] == "tao" || target.storage.yishan[1] == "tao") {
                return [0, 2];
              }
              return [1, 1];
            }
          }
        }
      },
      intro: {
        onunmark: function(content, player) {
          player.storage.yishan.length = 0;
        },
        mark: function(dialog, content, player) {
          dialog.add("<div class=\"text center\">最近失去的牌</div>");
          var cards = [];
          for (var i = 0; i < content.length; i++) {
            if (get.owner(content[i]) != player) {
              cards.push(content[i]);
              if (cards.length >= 4) break;
            }
          }
          if (cards.length) {
            dialog.add(cards);
          } else {
            dialog.add("（无）");
          }
        },
        content: function(content, player) {
          var str = "最近失去的牌：";
          var cards = [];
          for (var i = 0; i < content.length; i++) {
            if (get.owner(content[i]) != player) {
              cards.push(content[i]);
              if (cards.length >= 4) break;
            }
          }
          if (cards.length) {
            str += get.translation(cards);
          } else {
            str += "无";
          }
          return str;
        }
      }
    },
    yishan2: {
      trigger: { player: "loseEnd" },
      forced: true,
      popup: false,
      silent: true,
      content: function() {
        for (var i = 0; i < trigger.cards.length; i++) {
          player.storage.yishan.unshift(trigger.cards[i]);
        }
      }
    },
    guanhu: {
      trigger: { source: "damageEnd" },
      direct: true,
      filter: function(event) {
        return event.card && event.card.name == "sha" && event.player.num("he");
      },
      check: function(event, player) {
        return ai.get.attitude(player, event.player) < 0;
      },
      content: function() {
        "step 0";
        player.discardPlayerCard(trigger.player);
        "step 1";
        if (result.bool) {
          player.logSkill("guanhu", trigger.player);
        }
      },
      ai: {
        expose: 0.2
      }
    },

    chuanyang: {
      trigger: { player: "shaBegin" },
      check: function(event, player) {
        return ai.get.attitude(player, event.player) < 0;
      },
      filter: function(event, player) {
        // if(event.card&&get.color(event.card)=='red') return true;
        // return false;
        return get.distance(event.target, player, "attack") > 1;
      },
      content: function() {
        trigger.directHit = true;
      }
    },
    // poxing:{
    // 	trigger:{player:'shaEnd'},
    // 	frequent:true,
    // 	filter:function(trigger,player){
    // 		// if(trigger.targets&&trigger.target!=trigger.targets[trigger.targets.length-1])return false;
    // 		if(trigger.card&&trigger.card.skill=='poxing') return false;
    // 		if(trigger.targets.length>1) return false;
    // 		if(player.hp>trigger.target.hp) return false;
    // 		if(trigger.target.classList.contains('dead')) return false;
    // 		return true;
    // 		// return (get.itemtype(trigger.card)=='card'&&player.hp<=trigger.target.hp&&trigger.target.classList.contains('dead')==false);
    // 	},
    // 	content:function(){
    // 		player.useCard({
    // 			name:'sha',
    // 			nature:trigger.card.nature,
    // 			number:trigger.card.number,
    // 			suit:trigger.card.suit,
    // 			skill:'poxing'
    // 		},trigger.targets);
    // 	}
    // },
    poxing: {
      trigger: { source: "damageBegin" },
      filter: function(trigger, player) {
        return trigger.player.hp > player.hp;
      },
      forced: true,
      content: function() {
        trigger.num++;
      }
    },
    luomu: {
      trigger: { source: "damageEnd" },
      forced: true,
      filter: function(event, player) {
        return event.player.num("hej");
      },
      content: function() {
        trigger.player.discard(trigger.player.get("hej").randomGet());
      }
    },
    huanhun: {
      trigger: { global: "dying" },
      priority: 6,
      filter: function(event, player) {
        return event.player.hp <= 0 && player.num("he") > 0;
      },
      direct: true,
      content: function() {
        "step 0";
        player.chooseToDiscard("he", "是否发动【唤魂】？").ai = function(card) {
          if (ai.get.attitude(player, trigger.player) > 0) {
            return 8 - ai.get.value(card);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("huanhun", trigger.player);
          trigger.player.judge(function(card) {
            return get.color(card) == "red" ? 1 : -1;
          });
        } else {
          event.finish();
        }
        "step 2";
        if (result.bool) {
          trigger.player.recover();
        }
      },
      ai: {
        threaten: 1.6,
        expose: 0.2
      }
    },
    huanhun_old: {
      enable: "phaseUse",
      forbid: ["versus"],
      filter: function() {
        return game.dead.length > 0;
      },
      usable: 1,
      filterCard: function(card) {
        return get.suit(card) == "heart";
      },
      check: function(card) {
        return 10 - ai.get.value(card);
      },
      direct: true,
      content: function() {
        "step 0";
        var list = [];
        for (var i = 0; i < game.dead.length; i++) {
          list.push(game.dead[i].name);
        }
        player.chooseButton(ui.create.dialog([list, "character"]), function(button) {
          for (var i = 0; i < game.dead.length && game.dead[i].name != button.link; i++) ;
          return ai.get.attitude(_status.event.player, game.dead[i]) - 2;
        }, true);
        "step 1";
        if (result.bool) {
          for (var i = 0; i < game.dead.length && game.dead[i].name != result.buttons[0].link; i++) ;
          var dead = game.dead[i];
          dead.hp = 1;
          dead.revive();
          event.dead = dead;
          player.logSkill("huanhun", dead);
        } else {
          event.finish();
        }
        "step 2";
        if (event.dead) event.dead.draw(2);
      },
      ai: {
        order: 10,
        result: {
          player: function(player) {
            for (var i = 0; i < game.dead.length; i++) {
              if (ai.get.attitude(player, game.dead[i]) > 2) return 3;
            }
            return 0;
          }
        },
        threaten: 2
      }
    },
    yinyue: {
      trigger: { global: "recoverAfter" },
      check: function(event, player) {
        return ai.get.attitude(player, event.player) > 0;
      },
      prompt: function(event) {
        return "是否对" + get.translation(event.player) + "发动【引月】？";
      },
      content: function() {
        "step 0";
        trigger.player.draw();
        "step 1";
        if (player.num("h") < trigger.player.num("h")) {
          player.draw();
        }
      },
      ai: {
        expose: 0.2
      }
    },
    daofa: {
      trigger: { global: "damageAfter" },
      check: function(event, player) {
        return event.source && ai.get.attitude(player, event.source) < 0;
      },
      filter: function(event, player) {
        return event.source && event.source != player && event.source.num("he");
      },
      content: function() {
        trigger.source.chooseToDiscard("he", true);
      },
      ai: {
        expose: 0.2,
        threaten: 1.5
      }
    },
    daixing: {
      group: "daixing2",
      trigger: { player: "phaseEnd" },
      direct: true,
      content: function() {
        "step 0";
        player.chooseToDiscard("请选择发动代形的卡牌", "he", [1, player.num("he")]).ai = function(card) {
          if (ui.selected.cards.length >= 2) return 0;
          if (ui.selected.cards.length == 1) {
            if (player.num("h") > player.hp) {
              return 3 - ai.get.value(card);
            }
            return 0;
          }
          return 6 - ai.get.value(card);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("daixing");
          player.storage.daixing = result.cards.length;
          player.markSkill("daixing");
        } else {
          player.storage.daixing = 0;
          player.unmarkSkill("daixing");
        }
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              if (player.skills.contains("jueqing")) return;
              if (target.storage.daixing > 1) return 0.1;
              if (target.storage.daixing == 1) return 0.5;
            }
            return 1.5;
          }
        }
      },
      intro: {
        content: "mark"
      }
    },
    daixing2: {
      trigger: { player: "damageBegin" },
      filter: function(event, player) {
        return player.storage.daixing > 0;
      },
      priority: -20,
      popup: false,
      forced: true,
      content: function() {
        if (trigger.num >= player.storage.daixing) {
          trigger.num -= player.storage.daixing;
          player.storage.daixing = 0;
          player.unmarkSkill("daixing");
        } else {
          player.storage.daixing -= trigger.num;
          trigger.num = 0;
        }
        player.popup("daixing");
      }
    },
    swd_wuxie: {
      mod: {
        targetEnabled: function(card, player, target) {
          if (get.type(card) == "delay" && player != target) {
            return false;
          }
        }
      }
    },
    qingcheng: {
      trigger: { player: "phaseBegin" },
      frequent: true,
      content: function() {
        "step 0";
        if (event.cards == undefined) event.cards = [];
        player.judge(function(card) {
          if (get.color(card) == "red") return 1.5;
          return -1.5;
        }, ui.special);
        "step 1";
        if (result.judge > 0) {
          event.cards.push(result.card);
          // if(event.cards.length==2){
          // 	player.gain(event.cards);
          // 	event.finish();
          // }
          // else
          if (lib.config.auto_skill == false) {
            player.chooseBool("是否再次发动？");
          } else {
            event._result = { bool: true };
          }
        } else {
          player.gain(event.cards);
          event.finish();
        }
        "step 2";
        if (result.bool) {
          event.goto(0);
        } else {
          player.gain(event.cards);
        }
      },
      ai: {
        threaten: 1.4
      }
    },
    lingxin: {
      trigger: { player: "phaseEnd" },
      frequent: true,
      content: function() {
        "step 0";
        event.cards = get.cards(Math.max(3, get.cardCount(true, player) + 1));
        player.showCards(event.cards);
        "step 1";
        for (var i = 0; i < cards.length; i++) {
          if (get.suit(event.cards[i]) != "heart") {
            ui.discardPile.appendChild(cards[i]);
            event.cards.splice(i--, 1);
          }
        }
        if (event.cards.length == 0) {
          event.finish();
        } else {
          game.delay(0, 1000);
          player.$gain(event.cards);
        }
        "step 2";
        player.gain(event.cards);
      },
      ai: {
        result: {
          target: 2
        }
      }
    },
    lingwu: {
      unique: true,
      trigger: { player: "phaseAfter" },
      frequent: true,
      filter: function(event, player) {
        return get.cardCount(true, player) >= 3;
        ;
      },
      content: function() {
        player.phase();
      },
      ai: {
        order: -10,
        result: {
          target: 2
        }
      }
    },
    xianjiang: {
      enable: "phaseUse",
      position: "he",
      usable: 1,
      filterCard: function(card, player) {
        if (player.storage.xianjiang && player.storage.xianjiang.contains(card)) return false;
        return get.type(card) == "equip";
      },
      init: function(player) {
        player.storage.xianjiang = [];
      },
      check: function(card) {
        return 10 - ai.get.value(card);
      },
      prompt: "将一张装备牌永久转化为任意一张装备牌",
      content: function() {
        "step 0";
        var list = [];
        var suit = get.suit(cards[0]);
        var number = get.number(cards[0]);
        for (var i in lib.card) {
          if (lib.card[i].mode && lib.card[i].mode.contains(lib.config.mode) == false) continue;
          if (lib.card[i].type == "equip" && cards[0].name != i) {
            if (ai.get.equipValue({ name: i }) < 10) list.push([suit, number, i]);
          }
        }
        var dialog = ui.create.dialog([list, "vcard"]);
        player.chooseButton(dialog, true, function(button) {
          return ai.get.value({ name: button.link[2] }, player);
        });
        "step 1";
        cards[0].init(result.buttons[0].link);
        player.gain(cards[0]);
        player.$gain(cards[0]);
        game.delay();
        player.storage.xianjiang.add(cards[0]);
      },
      ai: {
        order: 9,
        result: {
          player: 1
        },
        threaten: 2
      }
    },
    xianjiang2: {
      trigger: { player: "phaseUseBegin" },
      forced: true,
      popup: false,
      filter: function(event, player) {
        return player.skills.contains("xianjiang");
      },
      content: function() {
        player.storage.xianjiang = [];
      }
    },
    xianjiang3: {
      enable: "phaseUse",
      filterCard: function(card) {
        return get.type(card, "trick") == "trick";
      },
      usable: 1,
      filter: function(event, player) {
        return player.num("e") == 0;
      },
      selectCard: 1,
      check: function(card) {
        return 8 - ai.get.value(card);
      },
      content: function() {
        for (var i = 0; i < ui.cardPile.childNodes.length; i++) {
          if (get.type(ui.cardPile.childNodes[i]) == "equip") {
            player.gain(ui.cardPile.childNodes[i]);
            player.$gain(ui.cardPile.childNodes[i]);
            game.delay();
            event.finish();
            return;
          }
        }
        for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
          if (get.type(ui.discardPile.childNodes[i]) == "equip") {
            player.gain(ui.discardPile.childNodes[i]);
            player.$gain(ui.discardPile.childNodes[i]);
            game.delay();
            event.finish();
            return;
          }
        }
        player.draw();
      },
      ai: {
        result: {
          player: 1
        },
        order: 9
      }
    },
    shengong: {
      trigger: { player: "chooseToRespondBegin" },
      filter: function(event, player) {
        if (event.responded) return false;
        if (!player.num("he")) return false;
        if (event.filterCard({ name: "shan" })) {
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i] != player && game.players[i].get("e", "2")) return true;
          }
        }
        if (event.filterCard({ name: "sha" })) {
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i] != player && game.players[i].get("e", "1")) return true;
          }
        }
        return false;
      },
      direct: true,
      content: function() {
        "step 0";
        var list = [];
        if (trigger.filterCard({ name: "shan" })) {
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i] != player && game.players[i].get("e", "2")) list.push(game.players[i].get("e", "2"));
          }
        }
        if (trigger.filterCard({ name: "sha" })) {
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i] != player && game.players[i].get("e", "1")) list.push(game.players[i].get("e", "1"));
          }
        }
        var dialog = ui.create.dialog("神工", list);
        for (var i = 0; i < dialog.buttons.length; i++) {
          dialog.buttons[i].querySelector(".info").innerHTML = get.translation(get.owner(dialog.buttons[i].link));
        }
        player.chooseButton(dialog, function(button) {
          var player = get.owner(button.link);
          if (get.subtype(button.link) == "equip2" && player.num("shan") == 0) {
            return 11 - ai.get.attitude(_status.event.player, player);
          }
          if (get.subtype(button.link) == "equip1" && player.num("sha") == 0) {
            return 11 - ai.get.attitude(_status.event.player, player);
          }
          return 5 - ai.get.attitude(_status.event.player, player);
        });
        "step 1";
        if (result.bool) {
          trigger.untrigger();
          trigger.responded = true;
          trigger.result = { bool: true, card: {} };
          if (get.subtype(result.buttons[0].link) == "equip1") trigger.result.card.name = "sha";
          else trigger.result.card.name = "shan";
          var target = get.owner(result.buttons[0].link);
          target.discard(result.buttons[0].link);
          target.draw();
          if (player.num("he")) player.chooseToDiscard(true, "he");
          player.logSkill("shengong");
        }
      },
      ai: {
        effect: {
          target: function(card, player, target, current) {
            if (target.num("he") <= 1) return;
            if (get.tag(card, "respondShan")) {
              for (var i = 0; i < game.players.length; i++) {
                if (game.players[i].get("e", "2")) {
                  if (ai.get.attitude(player, game.players[i]) > 0) return 0.6 / player.num("he");
                  return;
                }
              }
            }
            if (get.tag(card, "respondSha")) {
              for (var i = 0; i < game.players.length; i++) {
                if (game.players[i].get("e", "1")) {
                  if (ai.get.attitude(player, game.players[i]) > 0) return 0.6 / player.num("he");
                  return;
                }
              }
            }
          }
        }
      }
    },
    huajian: {
      trigger: { player: "phaseUseEnd" },
      direct: true,
      filter: function(event, player) {
        return player.num("he") > 0;
      },
      content: function() {
        "step 0";
        var next = player.chooseCardTarget({
          position: "he",
          filterTarget: function(card, player, target) {
            return lib.filter.targetEnabled({ name: "sha" }, player, target);
          },
          filterCard: true,
          ai1: function(card) {
            return ai.get.unuseful(card) + 9;
          },
          ai2: function(target) {
            return ai.get.effect(target, { name: "sha" }, player);
          },
          prompt: "是否发动【化剑】？"
        });
        "step 1";
        if (result.bool) {
          player.logSkill("huajian");
          player.useCard({ name: "sha" }, result.cards, result.targets, false);
        }
      },
      ai: {
        expose: 0.2
      }
    },
    polang: {
      trigger: { source: "damageEnd" },
      // group:'unequip',
      check: function(event, player) {
        return ai.get.attitude(player, event.player) < 0;
      },
      filter: function(event, player) {
        return event.player.num("e");
      },
      content: function() {
        trigger.player.discard(trigger.player.get("e"));
      },
      ai: {
        expose: 0.3
      }
      // mod:{
      // 	targetInRange:function(){
      // 		return true;
      // 	}
      // }
      // group:'polang2'
    },
    jikong: {
      trigger: { player: "loseEnd" },
      direct: true,
      filter: function(event, player) {
        if (player.num("h")) return false;
        for (var i = 0; i < event.cards.length; i++) {
          if (event.cards[i].original == "h") return true;
        }
        return false;
      },
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【亟空】？").ai = function(target) {
          var eff = ai.get.damageEffect(target, player, target, "thunder");
          return ai.get.attitude(player, target) * (eff - target.num("e"));
        };
        "step 1";
        if (result.bool) {
          player.logSkill("jikong", result.targets);
          event.target = result.targets[0];
          event.target.damage("thunder");
        } else {
          event.finish();
        }
        // "step 2"
        // player.recover();
      },
      group: "jikong2",
      ai: {
        threaten: function(player, target) {
          if (target.num("h")) return 0.8;
          return 2;
        }
      }
    },
    // jikong2:{
    // 	trigger:{player:'damageEnd'},
    // 	frequent:true,
    // 	filter:function(event,player){
    // 		return event.source&&event.source.num('h')>player.num('h');
    // 	},
    // 	content:function(){
    // 		player.draw(trigger.source.num('h')-player.num('h'));
    // 	},
    // 	ai:{
    // 		effect:{
    // 			target:function(card,player,target){
    // 				if(get.tag(card,'damage')){
    // 					var num=player.num('h')-target.num('h');
    // 					if(num>0){
    // 						if(player.hp>=4) return [1,num];
    // 						if(target.hp==3) return [1,num*0.5];
    // 						if(target.hp==2) return [1,num*0.2];
    // 					}
    // 				}
    // 			}
    // 		}
    // 	}
    // },
    jikong2: {
      trigger: { player: "phaseBegin" },
      direct: true,
      // filter:function(event,player){
      // 	return player.num('he')>0;
      // },
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【亟空】？", function(card, player, target) {
          return lib.filter.targetEnabled({ name: "sha", nature: "thunder" }, player, target);
        }).ai = function(target) {
          return ai.get.effect(target, { name: "sha", nature: "thunder" }, player);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("jikong");
          player.useCard({ name: "sha", nature: "thunder" }, result.targets, false);
        }
      },
      ai: {
        expose: 0.2
      }
    },
    xielei: {
      trigger: { player: ["useCard", "respondAfter"] },
      direct: true,
      filter: function(event) {
        return game.players.length > 2 && event.card && event.card.name == "sha";
      },
      content: function() {
        "step 0";
        game.delay(0.5);
        player.chooseTarget("是否发动【挟雷】？", function(card, player, target) {
          if (player == target) return false;
          if (trigger.name == "respond") {
            return trigger.source != target;
          } else {
            return !trigger.targets.contains(target);
          }
        }).ai = function(target) {
          return ai.get.damageEffect(target, player, player, "thunder");
        };
        "step 1";
        if (result.bool) {
          player.logSkill("xielei", result.targets, "thunder");
          result.targets[0].damage("thunder");
        }
      },
      ai: {
        expose: 0.3,
        threaten: 1.6
      }
    },
    ningjian: {
      group: ["ningjian1", "ningjian2"],
      ai: {
        effect: {
          target: function(card, player, target) {
            if (target.num("he") && (get.tag(card, "respondShan") || get.tag(card, "respondSha"))) return 0.6;
          }
        },
        respondSha: true,
        respondShan: true
      }
    },
    ningjian1: {
      enable: ["chooseToRespond", "chooseToUse"],
      filterCard: { color: "black" },
      viewAs: { name: "sha" },
      position: "he",
      prompt: "将一张黑色牌当杀打出",
      check: function(card) {
        return 6 - ai.get.value(card);
      }
    },
    ningjian2: {
      enable: ["chooseToRespond", "chooseToUse"],
      filterCard: { color: "red" },
      viewAs: { name: "shan" },
      position: "he",
      prompt: "将一张红色牌当闪打出",
      check: function(card) {
        return 6 - ai.get.value(card);
      }
    },
    duoren: {
      trigger: { target: "shaMiss" },
      filter: function(event) {
        return event.player.get("e", "1") != undefined;
      },
      check: function(event, player) {
        return ai.get.attitude(player, event.player) < 0;
      },
      priority: 5,
      content: function() {
        trigger.player.$give(trigger.player.get("e", "1"), player);
        player.gain(trigger.player.get("e", "1"));
      },
      ai: {
        effect: {
          target: function(card, player, target, current) {
            if (card.name == "sha" && target.num("h") > 1 && player.get("e", "1")) {
              return [1, 0.5, 0, -0.5];
            }
          }
        }
      }
      // filter:function(event){
      // 	return event.player.num('e')>0;
      // },
      // content:function(){
      // 	"step 0"
      // 	player.choosePlayerCard('是否获得'+get.translation(trigger.player)+'的一张装备牌？',
      // 	'e',trigger.player).ai=ai.get.buttonValue;
      // 	"step 1"
      // 	if(result.bool){
      // 		var card=result.buttons[0].link;
      // 		trigger.player.$give(card,player);
      // 		player.gain(card);
      // 	}
      // },
    },
    taixu: {
      enable: "phaseUse",
      filter: function(event, player) {
        return (!player.storage.taixu) && player.num("hej");
      },
      filterTarget: function(card, player, target) {
        return player != target && target.hp > 1;
      },
      content: function() {
        player.discard(player.get("hej"));
        player.storage.taixu = true;
        target.damage(player.maxHp - player.hp);
      },
      ai: {
        basic: {
          order: 1
        },
        result: {
          target: function(player, target) {
            if (player.maxHp - player.hp < 2) return 0;
            return -2;
          },
          player: function(player, target) {
            return -0.5 * player.num("he");
          }
        }
      }
    },
    pozhen: {
      trigger: { player: "damageEnd" },
      filter: function(event, player) {
        return event.source && event.source.num("h") != player.num("h");
      },
      // check:function(event,player){
      // 	return ai.get.attitude(player,event.source)<0;
      // },
      direct: true,
      content: function() {
        "step 0";
        var num = player.num("h") - trigger.source.num("h");
        event.num = num;
        if (num > 0) {
          player.chooseToDiscard(num, "是否弃置" + num + "张手牌，并对" + get.translation(trigger.source) + "造成一点伤害？").ai = function(card) {
            if (ai.get.damageEffect(trigger.source, player, player) > 0 && num <= 2) {
              return 6 - ai.get.value(card);
            }
            return -1;
          };
        } else if (num < 0) {
          player.chooseBool("是否弃置" + get.translation(trigger.source) + (-num) + "张手牌？").ai = function() {
            return ai.get.attitude(player, trigger.source) < 0;
          };
        } else {
          event.finish();
        }
        "step 1";
        if (result.bool) {
          player.logSkill("pozhen", trigger.source);
          if (event.num > 0) {
            trigger.source.damage();
          } else {
            var cards = trigger.source.get("h");
            cards.sort(lib.sort.random);
            trigger.source.discard(cards.slice(0, -event.num));
          }
        }
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              if (player.skills.contains("jueqing")) return [1, -1];
              var num = player.num("h") - target.num("h");
              if (num > 0) {
                return [1, 0, 0, -num / 2];
              }
              if (num < 0) {
                return [1, 0, 0, -0.5];
              }
            }
          }
        }
      }
    },
    tanlin_defence: {
      trigger: { player: "damageEnd" },
      filter: function(event, player) {
        return player.num("h") && event.source && event.source.num("h");
      },
      direct: true,
      content: function() {
        "step 0";
        player.chooseToDiscard([1, trigger.source.num("h")], "弃置任意张手牌并令伤害来源弃置等量手牌").ai = function(card) {
          if (ui.selected.cards.length >= trigger.source.num("h")) return -1;
          if (ui.selected.cards.length == 0) return 8 - ai.get.value(card);
          return 4 - ai.get.value(card);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("tanlin");
          trigger.source.discard(trigger.source.get("h", lib.sort.random, result.cards.length));
        } else {
          event.finish();
        }
        "step 2";
        player.draw();
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage") && target.num("h") && target.hp > 1 && player != target) return [1, 0.2, 0, -0.2];
          }
        }
      }
    },
    tanlin: {
      enable: "phaseUse",
      usable: 1,
      group: "tanlin4",
      filterTarget: function(card, player, target) {
        return player != target && target.num("h");
      },
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      content: function() {
        "step 0";
        player.chooseToCompare(target);
        "step 1";
        if (result.bool) {
          if (target.skills.contains("tanlin2") == false) {
            target.addSkill("tanlin2");
            player.addSkill("tanlin3");
            player.gain([result.player, result.target]);
            player.$gain2([result.player, result.target]);
          }
        } else {
          player.damage(target);
        }
      },
      ai: {
        result: {
          target: function(player, target) {
            var cards = player.get("h");
            var num = target.num("h");
            if (num > cards.length + 3 && player.hp > 1) return -2;
            if (num > cards.length + 1 && player.hp > 1) return -1;
            if (num == cards.length - 1 && player.hp > 1) return -1;
            for (var i = 0; i < cards.length; i++) {
              if (cards[i].number > 9) return num == 1 ? -1 : -0.5;
            }
            return 0;
          }
        },
        order: 9
      }
    },
    tanlin2: {
      trigger: { global: "phaseAfter" },
      forced: true,
      content: function() {
        player.removeSkill("tanlin2");
      }
      // mod:{
      // 	cardEnabled:function(){
      // 		return false;
      // 	},
      // 	cardUsable:function(){
      // 		return false;
      // 	},
      // 	cardRespondable:function(){
      // 		return false;
      // 	},
      // 	cardSavable:function(){
      // 		return false;
      // 	}
      // },
    },
    tanlin3: {
      trigger: { global: "phaseAfter" },
      forced: true,
      popup: false,
      content: function() {
        player.removeSkill("tanlin3");
      },
      mod: {
        cardUsable: function(card, player, num) {
          if (card.name == "sha") return num + 1;
        }
      }
    },
    tanlin4: {
      mod: {
        targetInRange: function(card, player, target, now) {
          if (target.skills.contains("tanlin2")) return true;
        }
      }
    },
    yunchou: {
      enable: "phaseUse",
      usable: 1,
      filterTarget: function(card, player, target) {
        return player != target && target.num("h");
      },
      filterCard: true,
      selectCard: [1, Infinity],
      content: function() {
        "step 0";
        var card = target.get("h").randomGet();
        target.discard(card);
        var color = get.color(card);
        var suit = get.suit(card);
        var num1 = 0, num2 = 0;
        for (var i = 0; i < cards.length; i++) {
          if (get.color(cards[i]) == color) num1++;
          else num2++;
          // if(get.suit(cards[i])==suit) num1++;
        }
        event.num1 = num1;
        event.num2 = num2;
        "step 1";
        player.draw(event.num1);
        "step 2";
        target.draw(event.num2);
      },
      check: function(card) {
        if (ui.selected.cards.length) return 0;
        return 4 - ai.get.value(card);
      },
      ai: {
        order: 5,
        result: {
          target: -0.5
        },
        threaten: 1.3
      }
    },
    qimou: {
      trigger: { player: "damageEnd" },
      frequent: true,
      filter: function(event, player) {
        return _status.currentPhase != player;
      },
      content: function() {
        "step 0";
        var cards = get.cards(1);
        event.card = cards[0];
        player.gain(cards, "gain2");
        game.log(get.translation(player) + "获得了" + get.translation(event.card));
        "step 1";
        var gained = event.card;
        if (lib.filter.filterCard(gained)) {
          var next = player.chooseToUse();
          next.filterCard = function(card) {
            return card == gained;
          };
          next.prompt = "是否使用" + get.translation(gained) + "？";
          // if(get.select(lib.card[gained.name])[1]!=-1){
          // 	next.selectCard=-1;
          // }
        }
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage") && _status.currentPhase != target) {
              if (player.skills.contains("jueqing")) return [1, -1.5];
              return [1, 0.5];
            }
          }
        }
      }
    },
    lexue: {
      group: ["lexue1", "lexue2"]
    },
    lexue1: {
      trigger: { player: "phaseBegin" },
      forced: true,
      popup: false,
      content: function() {
        player.removeSkill(player.storage.lexue);
        switch (Math.floor(Math.random() * 4)) {
          case 0:
            if (lib.skill.zhiheng) {
              player.addSkill("zhiheng");
              player.storage.lexue = "zhiheng";
              player.popup("zhiheng");
            }
            break;
          case 1:
            if (lib.skill.jizhi) {
              player.addSkill("jizhi");
              player.storage.lexue = "jizhi";
              player.popup("jizhi");
            }
            break;
          case 2:
            if (lib.skill.dimeng) {
              player.addSkill("dimeng");
              player.storage.lexue = "dimeng";
              player.popup("dimeng");
            }
            break;
          case 3:
            if (lib.skill.quhu) {
              player.addSkill("quhu");
              player.storage.lexue = "quhu";
              player.popup("quhu");
            }
            break;
        }
      }
    },
    lexue2: {
      trigger: { player: "phaseEnd" },
      forced: true,
      popup: false,
      content: function() {
        player.removeSkill(player.storage.lexue);
        switch (Math.floor(Math.random() * 4)) {
          case 0:
            if (lib.skill.yiji) {
              player.addSkill("yiji");
              player.storage.lexue = "yiji";
              player.popup("yiji");
            }
            break;
          case 1:
            if (lib.skill.jijiu) {
              player.addSkill("jijiu");
              player.storage.lexue = "jijiu";
              player.popup("jijiu");
            }
            break;
          case 2:
            if (lib.skill.guidao) {
              player.addSkill("guidao");
              player.storage.lexue = "guidao";
              player.popup("guidao");
            }
            break;
          case 3:
            if (lib.skill.fankui) {
              player.addSkill("fankui");
              player.storage.lexue = "fankui";
              player.popup("fankui");
            }
            break;
        }
      }
    },
    tianshu: {
      unique: true,
      enable: "phaseUse",
      priority: -9,
      group: "tianshu2",
      filterCard: { type: ["trick", "delay"] },
      filter: function(event, player) {
        return player.num("h", { type: "trick" }) > 0;
      },
      filterTarget: function(card, player, target) {
        var names = [];
        if (target.name && !target.classList.contains("unseen")) names.add(target.name);
        if (target.name1 && !target.classList.contains("unseen")) names.add(target.name1);
        if (target.name2 && !target.classList.contains("unseen2")) names.add(target.name2);
        var pss = player.get("s");
        for (var i = 0; i < names.length; i++) {
          var info = lib.character[names[i]];
          if (info) {
            var skills = info[3];
            for (var j = 0; j < skills.length; j++) {
              if (lib.translate[skills[j] + "_info"] && lib.skill[skills[j]] &&
                !lib.skill[skills[j]].unique && !pss.contains(skills[j])) {
                return true;
              }
            }
          }
          return false;
        }
      },
      createDialog: function(player, target) {
        var names = [];
        var list = [];
        if (target.name && !target.classList.contains("unseen")) names.add(target.name);
        if (target.name1 && !target.classList.contains("unseen")) names.add(target.name1);
        if (target.name2 && !target.classList.contains("unseen2")) names.add(target.name2);
        var pss = player.get("s");
        for (var i = 0; i < names.length; i++) {
          var info = lib.character[names[i]];
          if (info) {
            var skills = info[3];
            for (var j = 0; j < skills.length; j++) {
              if (lib.translate[skills[j] + "_info"] && lib.skill[skills[j]] &&
                !lib.skill[skills[j]].unique &&
                !pss.contains(skills[j])) {
                list.push(skills[j]);
              }
            }
          }
        }
        var dialog = ui.create.dialog();
        dialog.add("选择获得一项技能");
        var clickItem = function() {
          _status.event._result = this.link;
          game.resume();
        };
        for (i = 0; i < list.length; i++) {
          if (lib.translate[list[i] + "_info"]) {
            var translation = get.translation(list[i])[0] + get.translation(list[i])[1];
            var item = dialog.add("<div class=\"popup\" style=\"width:50%;display:inline-block\"><div class=\"skill\">【" +
              translation + "】</div><div>" + lib.translate[list[i] + "_info"] + "</div></div>");
            item.addEventListener("click", clickItem);
            item.link = list[i];
          }
        }
        dialog.add(ui.create.div(".placeholder"));
        return dialog;
      },
      content: function() {
        "step 0";
        ui.auto.hide();
        event.dialog = lib.skill.tianshu.createDialog(player, target);
        game.pause();
        "step 1";
        if (player.storage.tianshu) {
          player.unmark(player.storage.tianshu + "_charactermark");
        }
        ui.auto.show();
        event.dialog.close();
        var link = result;
        player.addSkill(link);
        player.skills.remove(link);
        player.additionalSkills.tianshu = link;
        player.popup(link);
        player.markCharacter(target.name, {
          name: get.translation(link),
          content: lib.translate[link + "_info"]
        });
        player.storage.tianshu = target.name;
        player.checkMarks();
      }
    },
    tianshu2: {
      trigger: { player: "phaseBegin" },
      direct: true,
      priority: -9,
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【天书】？", lib.skill.tianshu.filterTarget).ai = function(target) {
          if (target.maxHp < 5) return Math.random() * (5 - target.maxHp);
          return -1;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("tianshu", result.targets);
          event.target = result.targets[0];
          if (event.isMine()) {
            ui.auto.hide();
            event.dialog = lib.skill.tianshu.createDialog(player, result.targets[0]);
            game.pause();
          } else {
            var target = result.targets[0];
            var names = [];
            var list = [];
            if (target.name && !target.classList.contains("unseen")) names.add(target.name);
            if (target.name1 && !target.classList.contains("unseen")) names.add(target.name1);
            if (target.name2 && !target.classList.contains("unseen2")) names.add(target.name2);
            var pss = player.get("s");
            for (var i = 0; i < names.length; i++) {
              var info = lib.character[names[i]];
              if (info) {
                var skills = info[3];
                for (var j = 0; j < skills.length; j++) {
                  if (lib.translate[skills[j] + "_info"] && lib.skill[skills[j]] &&
                    !lib.skill[skills[j]].unique &&
                    !pss.contains(skills[j])) {
                    list.push(skills[j]);
                  }
                }
              }
            }
            if (!list.length) {
              event.finish();
            } else {
              event._result = list.randomGet();
            }
          }
        } else {
          event.finish();
        }
        "step 2";
        if (player.storage.tianshu) {
          player.unmark(player.storage.tianshu + "_charactermark");
        }
        ui.auto.show();
        if (event.dialog) {
          event.dialog.close();
        }
        var link = result;
        var target = event.target;
        player.addSkill(link);
        player.skills.remove(link);
        player.additionalSkills.tianshu = link;
        player.markCharacter(target.name, {
          name: get.translation(link),
          content: lib.translate[link + "_info"]
        });
        player.storage.tianshu = target.name;
        player.checkMarks();
        player.popup(link);
      },
      ai: {
        expose: 0.2,
        threaten: 2
      }
    },
    luomei: {
      trigger: { player: ["useCard", "respond"] },
      frequent: true,
      filter: function(event, player) {
        if (!event.cards) return false;
        for (var i = 0; i < event.cards.length; i++) {
          if (get.suit(event.cards[i]) == "club") return true;
        }
        return false;
      },
      content: function() {
        var num = 0;
        for (var i = 0; i < trigger.cards.length; i++) {
          if (get.suit(trigger.cards[i]) == "club") num++;
        }
        player.draw(num);
      }
    },
    xingdian: {
      enable: "phaseUse",
      usable: 1,
      filterCard: true,
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      filterTarget: function(card, player, target) {
        return player != target && target.num("he") > 0;
      },
      check: function(card) {
        return 7 - ai.get.value(card);
      },
      selectTarget: [1, 2],
      content: function() {
        target.chooseToDiscard(true, "he");
      },
      ai: {
        order: 9,
        result: {
          target: function(player, target) {
            if (target.num("he") == 1) return -1.5;
            return -1;
          }
          // player:function(player){
          // 	var num=0;
          // 	for(var i=0;i<game.players.length;i++){
          // 		if(game.players[i]!=player){
          // 			if(ai.get.attitude(player,game.players[i])>0) num--;
          // 			else num++;
          // 		}
          // 	}
          // 	return num;
          // }
        }
      }
    },
    yulin: {
      trigger: { player: "damageBefore" },
      priority: -10,
      filter: function(event, player) {
        return player.num("he", { type: "equip" });
      },
      direct: true,
      content: function() {
        "step 0";
        player.chooseToDiscard("he", "是否弃置一张装备牌抵消伤害？", function(card, player) {
          return get.type(card) == "equip";
        }).ai = function(card) {
          if (player.hp == 1 || trigger.num > 1) {
            return 9 - ai.get.value(card);
          }
          if (player.hp == 2) {
            return 8 - ai.get.value(card);
          }
          return 7 - ai.get.value(card);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("yulin");
          game.delay();
          trigger.untrigger();
          trigger.finish();
        }
      }
    },
    funiao: {
      enable: "phaseUse",
      discard: false,
      prepare: function(cards, player, targets) {
        player.$give(1, targets[0]);
      },
      filterTarget: function(card, player, target) {
        if (player == target) return false;
        if (player.num("h") == 0) return false;
        if (target.storage.funiao) return false;
        return true;
      },
      filterCard: true,
      check: function(card) {
        if (get.owner(card).num("h") < get.owner(card).hp) return 0;
        return 4 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        target.gain(cards);
        target.storage.funiao = true;
        target.addSkill("funiao2");
        game.delay();
        "step 1";
        if (event.isMine()) {
          event.dialog = ui.create.dialog(get.translation(target.name) + "的手牌", target.get("h"));
          game.pause();
          ui.create.confirm("o");
        } else {
          event.finish();
        }
        "step 2";
        event.dialog.close();
      },
      ai: {
        result: {
          target: 1
        },
        order: 1
      }
    },
    funiao2: {
      trigger: { global: "phaseUseEnd" },
      forced: true,
      popup: false,
      content: function() {
        player.storage.funiao = false;
      }
    },
    lingbo: {
      trigger: { player: "respond" },
      filter: function(event, player) {
        return event.card.name == "shan";
      },
      frequent: true,
      content: function() {
        player.draw(2);
      },
      ai: {
        mingzhi: false,
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "respondShan")) {
              var shans = target.num("h", "shan");
              var hs = target.num("h");
              if (shans > 1) return [0, 1];
              if (shans && hs > 2) return [0, 1];
              if (shans) return [0, 0];
              if (hs > 2) return [0, 0];
              if (hs > 1) return [1, 0.5];
              return [1.5, 0];
            }
          }
        },
        threaten: 0.8
      }
    },
    yunshen: {
      trigger: { player: "respond" },
      filter: function(event, player) {
        return event.card.name == "shan";
      },
      frequent: true,
      init: function(player) {
        player.storage.yunshen = 0;
      },
      content: function() {
        player.storage.yunshen++;
        player.markSkill("yunshen");
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "respondShan")) {
              var shans = target.num("h", "shan");
              var hs = target.num("h");
              if (shans > 1) return [1, 1];
              if (shans && hs > 2) return [1, 1];
              if (shans) return [1, 0.5];
              if (hs > 2) return [1, 0.3];
              if (hs > 1) return [1, 0.2];
              return [1.2, 0];
            }
          }
        },
        threaten: 0.8
      },
      intro: {
        content: "mark"
      },
      group: "yunshen2"
    },
    yunshen2: {
      trigger: { player: "phaseBegin" },
      forced: true,
      filter: function(event, player) {
        return player.storage.yunshen > 0;
      },
      content: function() {
        player.draw(player.storage.yunshen);
        player.storage.yunshen = 0;
        player.unmarkSkill("yunshen");
      },
      mod: {
        globalTo: function(from, to, distance) {
          if (typeof to.storage.yunshen == "number") return distance + to.storage.yunshen;
        }
      }
    },
    xuehuang: {
      enable: "phaseUse",
      usable: 1,
      filterCard: { color: "red" },
      nodelay: true,
      check: function(card) {
        return 6 - ai.get.value(card);
      },
      filterTarget: function(card, player, target) {
        return get.distance(player, target) <= 1 || player == target;
      },
      filter: function(event, player) {
        return player.num("h", { color: "red" }) > 0;
      },
      selectTarget: -1,
      content: function() {
        target.damage("fire");
      },
      line: "fire",
      ai: {
        order: 1,
        result: {
          target: function(player, target) {
            return ai.get.damageEffect(target, player, target, "fire");
          }
        }
      }
    },
    zhuyu: {
      trigger: { global: "damageBegin" },
      filter: function(event, player) {
        if (event.player.classList.contains("linked") == false) return false;
        if (event.nature == "fire") return false;
        if (player.num("h", { color: "red" })) return true;
        return false;
      },
      direct: true,
      content: function() {
        "step 0";
        player.chooseToDiscard("朱羽：是否弃置一张红色手牌使其受到一点火焰伤害？", function(card) {
          return get.color(card) == "red";
        }).ai = function(card) {
          if (trigger.player.hasSkillTag("nofire")) return 0;
          if (ai.get.damageEffect(trigger.player, player, player, "fire") > 0) {
            return 9 - ai.get.value(card);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("zhuyu", trigger.player, "fire");
          trigger.player.damage("fire");
        }
      }
    },
    ningshuang: {
      trigger: { target: "useCardToBegin" },
      filter: function(event, player) {
        if (get.color(event.card) != "black") return false;
        if (!event.player) return false;
        if (event.player == player) return false;
        if (event.player.classList.contains("linked") &&
          event.player.classList.contains("turnedover")) return false;
        if (player.num("h", { color: "black" })) return true;
        return false;
      },
      direct: true,
      content: function() {
        "step 0";
        player.chooseToDiscard("是否弃置一张黑色手牌使其横置或翻面？", function(card) {
          return get.color(card) == "black";
        }).ai = function(card) {
          if (ai.get.attitude(player, trigger.player) < 0) {
            return 9 - ai.get.value(card);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("ningshuang");
          if (trigger.player.classList.contains("turnedover")) {
            trigger.player.loseHp();
          }
          if (trigger.player.classList.contains("linked")) {
            trigger.player.turnOver();
          } else {
            trigger.player.link();
            player.draw();
          }
        }
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.color(card) == "black" && ai.get.attitude(target, player) < 0 && target.num("h") > 0) {
              return [1, 0.1, 0, -target.num("h") / 4];
            }
          }
        }
      }
    },
    zaowu: {
      enable: "phaseUse",
      usable: 1,
      position: "he",
      filterCard: function(card, player, target) {
        if (ui.selected.cards.length == 0) return true;
        for (var i = 0; i < ui.selected.cards.length; i++) {
          if (get.type(ui.selected.cards[i], "trick") == get.type(card, "trick")) return false;
        }
        return true;
      },
      selectCard: 3,
      check: function(card) {
        return 10 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        var list = [];
        var suit = ["heart", "diamond", "club", "spade"].randomGet();
        var number = Math.floor(Math.random() * 13) + 1;
        for (var i in lib.card) {
          if (lib.card[i].mode && lib.card[i].mode.contains(lib.config.mode) == false) continue;
          if (ai.get.value({ name: i }) >= 10) continue;
          if (i != "list") list.push([suit, number, i]);
        }
        var dialog = ui.create.dialog([list, "vcard"]);
        player.chooseButton(dialog, 2, true, function(button) {
          return ai.get.value({ name: button.link[2] }, player);
        });
        "step 1";
        var cards = [ui.create.card(), ui.create.card()];
        cards[0].init(result.buttons[0].link);
        cards[1].init(result.buttons[1].link);
        player.gain(cards);
        player.$gain(cards);
        game.delay();
      },
      ai: {
        order: 8,
        result: {
          player: 1
        },
        threaten: 1.6
      }
    },
    xielv: {
      trigger: { player: "phaseDiscardEnd" },
      filter: function(event, player) {
        var cards = player.get("h");
        if (cards.length < 2) return false;
        var color = get.color(cards[0]);
        for (var i = 1; i < cards.length; i++) {
          if (get.color(cards[i]) != color) return false;
        }
        return true;
      },
      direct: true,
      content: function() {
        "step 0";
        var todiscard = [];
        var ainum = 0;
        var cards;
        var att;
        var filter = { color: get.color(player.get("h")[0]) == "red" ? "black" : "red" };
        for (var i = 0; i < game.players.length; i++) {
          att = ai.get.attitude(player, game.players[i]);

          cards = game.players[i].get("e", filter);
          if (att > 0) {
            ainum -= cards.length;
          } else if (att < 0) {
            ainum += cards.length;
          }
          todiscard = todiscard.concat(cards);

          cards = game.players[i].get("j", filter);
          if (att > 0) {
            ainum += cards.length;
          } else if (att < 0) {
            ainum -= cards.length;
          }
          todiscard = todiscard.concat(cards);
        }
        var choice = [];
        if (player.hp < player.maxHp) {
          choice.push("recover_hp");
        }
        if (todiscard.length) {
          choice.push("discard_card");
        }
        choice.push("cancel");
        if (choice.length > 1) {
          if (event.isMine()) {
            event.dialog = ui.create.dialog("是否发动【谐率】？");
          }
          player.chooseControl(choice).ai = function() {
            if (choice.contains("recover_hp")) return "recover_hp";
            else if (ainum > 0) return "discard_card";
            else return "cancel";
          };
          event.todiscard = todiscard;
          event.filter = filter;
        } else {
          event.finish();
        }
        "step 1";
        if (event.dialog) event.dialog.close();
        event.control = result.control;
        if (event.control != "recover_hp" && event.control != "discard_card") {
          event.finish();
        } else {
          player.showHandcards();
          player.logSkill("xielv");
        }
        "step 2";
        if (event.control == "recover_hp") {
          player.recover();
          event.finish();
        } else if (event.control == "discard_card") {
          event.targets = game.players.slice(0);
          event.targets.sort(lib.sort.seat);
        } else {
          event.finish();
        }
        "step 3";
        if (event.targets && event.targets.length) {
          var target = event.targets.shift();
          target.discard(target.get("ej", event.filter));
          event.redo();
        }
      },
      ai: {
        expose: 0.1
      }
    },
    xiaomoyu: {
      trigger: { source: "damageEnd" },
      priority: 1,
      forced: true,
      content: function() {
        "step 0";
        if (player.hp < player.maxHp) {
          player.chooseControl("draw_card", "recover_hp", function(event, target) {
            if (player.num("h") >= player.hp) return "recover_hp";
            return "draw_card";
          });
        } else {
          player.draw();
          event.finish();
        }
        "step 1";
        if (result.control == "draw_card") {
          player.draw();
        } else {
          player.recover();
        }
      },
      ai: {
        maixie: true,
        effect: {
          target: function(card, player, target, current) {
            if (card.name == "sha" && (get.color(card) == "red")) {
              return [1, -2];
            }
          }
        }
      }
    },
    xielv_old: {
      trigger: { player: "phaseDiscardEnd" },
      filter: function(event, player) {
        var cards = player.get("h");
        if (cards.length < 2) return false;
        var color = get.color(cards[0]);
        for (var i = 1; i < cards.length; i++) {
          if (get.color(cards[i]) != color) return false;
        }
        return true;
      },
      content: function() {
        "step 0";
        player.showHandcards();
        "step 1";
        "step 2";
        var num = player.num("h");
        event.color = get.color(player.get("h")[0]);
        player.chooseTarget("选择至多" + num + "名角色各摸一张牌", [1, num], function(card, player, target) {
          return true;
        }).ai = function(target) {
          return ai.get.attitude(player, target);
        };
        "step 3";
        if (result.bool) {
          event.num = 0;
          event.targets = result.targets;
        } else {
          event.finish();
        }
        "step 4";
        if (event.num < event.targets.length) {
          event.current = event.targets[event.num];
          event.current.draw();
        } else {
          event.finish();
        }
        "step 5";
        var renum = event.current.num("e", { color: event.color });
        if (renum) {
          event.current.recover();
        }
        event.num++;
        event.goto(4);
      },
      ai: {
        threaten: 1.4,
        expose: 0.1
      }
    },
    xiangu: {
      mod: {
        maxHandcard: function(player, num) {
          if (player.hp < player.maxHp) return num + player.maxHp - player.hp;
        }
      }
    },
    tianhuo: {
      enable: "phaseUse",
      filterTarget: function(card, player, target) {
        return target.num("j") > 0;
      },
      usable: 1,
      selectTarget: -1,
      filter: function() {
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].num("j")) return true;
        }
        return false;
      },
      line: "fire",
      content: function() {
        "step 0";
        event.num = target.num("j");
        target.discard(target.get("j"));
        "step 1";
        target.damage(event.num, "fire", "nosource");
      },
      ai: {
        order: 1,
        result: {
          target: function(player, target) {
            var eff = ai.get.damageEffect(target, player);
            if (eff >= 0) return eff + 1;
            var judges = target.get("j");
            if (!judges.length) return 0;
            if (target.hp == 1 || judges.length > 1) return -judges.length;
            var name = judges[0].viewAs || judges[0].name;
            if (name == "shandian" || name == "huoshan" || name == "hongshui") return -judges.length;
            return 0;
          }
        }
      }
    },
    huanyin: {
      trigger: { target: "useCardToBefore" },
      forced: true,
      priority: 5.9,
      filter: function(event, player) {
        return event.player != player;
      },
      content: function() {
        "step 0";
        var effect = ai.get.effect(player, trigger.card, trigger.player, player);
        player.judge(function(card) {
          switch (get.suit(card)) {
            case "spade":
              return -effect;
            case "heart":
              return 1;
            default:
              return 0;
          }
        });
        "step 1";
        switch (result.suit) {
          case "spade": {
            trigger.untrigger();
            trigger.finish();
            break;
          }
          case "heart": {
            player.draw();
            break;
          }
        }
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            return 0.7;
          }
        },
        threaten: 0.8
      }
    },
    xuanzhou: {
      enable: "phaseUse",
      usable: 1,
      discard: false,
      filter: function(event, player) {
        return player.num("he", { type: "trick" }) > 0;
      },
      prepare: function(cards, player, targets) {
        player.$throw(cards);
      },
      position: "he",
      filterCard: { type: "trick" },
      filterTarget: function(card, player, target) {
        return player != target;
      },
      check: function(card) {
        return 7 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        var list = [];
        for (var i in lib.card) {
          if (lib.card[i].mode && lib.card[i].mode.contains(lib.config.mode) == false) continue;
          if (lib.card[i].type == "delay") list.push([cards[0].suit, cards[0].number, i]);
        }
        var dialog = ui.create.dialog([list, "vcard"]);
        var bing = target.num("h") <= 1;
        player.chooseButton(dialog, true, function(button) {
          if (bing && button.link[2] == "bingliang") {
            return 2;
          }
          if (button.link[2] == "lebu") {
            return 1;
          }
          if (button.link[2] == "guiyoujie") {
            return 0.5;
          }
          return 0.2;
        }).filterButton = function(button) {
          return !target.hasJudge(button.link[2]);
        };
        "step 1";
        // console.log(result.links[0][2]);
        target.addJudge(result.links[0][2], cards);
      },
      ai: {
        result: {
          target: -1
        },
        order: 9.5
      }
    },
    tianlun: {
      unique: true,
      trigger: { global: "judge" },
      direct: true,
      filter: function(event) {
        if (event.card) return true;
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].num("j")) return true;
        }
        return false;
      },
      content: function() {
        "step 0";
        var list = [];
        if (trigger.card) list.push(trigger.card);
        for (var i = 0; i < game.players.length; i++) {
          list = list.concat(game.players[i].get("j"));
        }
        var dialog = ui.create.dialog("天轮：替换" + get.translation(trigger.player.judging) +
          "(" + get.translation(get.suit(trigger.player.judging)) + get.translation(get.number(trigger.player.judging)) + ")", list);
        player.chooseButton(dialog, function(button) {
          var card = button.link;
          var trigger = _status.event.parent._trigger;
          var player = _status.event.player;
          var result = trigger.judge(card) - trigger.judge(trigger.player.judging);
          var attitude = ai.get.attitude(player, trigger.player);
          if (attitude == 0 || result == 0) return 1;
          if (attitude > 0) {
            return result + 1;
          } else {
            return -result + 1;
          }
        });
        "step 1";
        if (result.bool) {
          event.card = result.buttons[0].link;
          if (get.owner(event.card)) get.owner(event.card).discard(event.card);
          else trigger.player.$throw(event.card, 1000);
        }
        "step 2";
        if (event.card) {
          player.logSkill("tianlun");
          if (trigger.player.judging.clone) trigger.player.judging.clone.moveTo(player).delete();
          else player.$draw();
          player.gain(trigger.player.judging);
          trigger.player.judging = event.card;
          trigger.position.appendChild(event.card);
          game.log(get.translation(trigger.player) + "的判定牌改为" + get.translation(event.card));
          event.card.expired = true;
          game.delay(2);
        }
      },
      ai: {
        tag: {
          rejudge: 0.6
        }
      }
    },
    longyin: {
      enable: "phaseUse",
      usable: 1,
      filterCard: function(card, player) {
        if (get.number(card) % game.players.length == 0) return false;
        for (var i = 0; i < game.players.length; i++) {
          if (get.distance(player, game.players[i], "absolute") == get.number(card) % game.players.length) {
            break;
          }
        }
        if (!game.players[i]) return false;
        if (game.players[i].num("e") == 0) return false;
        for (var i = 0; i < ui.selected.cards.length; i++) {
          if (get.number(card) % game.players.length ==
            get.number(ui.selected.cards[i]) % game.players.length) return false;
          if (get.color(card) != get.color(ui.selected.cards[i])) return false;
        }
        return true;
      },
      selectCard: [1, Infinity],
      filterTarget: function(card, player, target) {
        if (player == target) return false;
        if (target.num("ej") == 0) return false;
        for (var i = 0; i < ui.selected.cards.length; i++) {
          if (get.number(ui.selected.cards[i]) % game.players.length ==
            get.distance(player, target, "absolute")) return true;
        }
        return false;
      },
      selectTarget: -1,
      content: function() {
        "step 0";
        if (target.num("e")) {
          player.choosePlayerCard(target, true, "e");
        }
        "step 1";
        try {
          target.discard(1, result.buttons[0].link);
        } catch (e) {
        }
        if (target == targets[targets.length - 1]) player.draw(targets.length);
      },
      check: function(card) {
        return 8 - ai.get.value(card);
      },
      ai: {
        order: 10,
        result: {
          target: -1
        }
      }
    },
    lanzhi: {
      trigger: { source: "damageBefore" },
      filter: function(event, player) {
        return player.skills.contains("lanzhi2") == false;
      },
      check: function(event, player) {
        if (event.source == player) {
          if (event.num > 1) return ai.get.attitude(player, event.player) >= 0;
          return ai.get.attitude(player, event.player) >= -2;
        } else {
          if (player.hp == 1 || event.num > 1) return true;
          if (player.hp == 2) return ai.get.attitude(player, event.player) >= -2;
          return ai.get.attitude(player, event.player) >= 0;
        }
      },
      content: function() {
        trigger.untrigger();
        trigger.finish();
        trigger.source.draw(2);
        player.addTempSkill("lanzhi2", "phaseBegin");
      }
    },
    lanzhi2: {},
    duanyi: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("h", "sha") > 1;
      },
      filterCard: { name: "sha" },
      selectCard: 2,
      filterTarget: function(card, player, target) {
        return player != target;
      },
      check: function(card) {
        return 10 - ai.get.value(card);
      },
      content: function() {
        "step 0";
        target.damage();
        "step 1";
        if (target.isAlive()) {
          target.turnOver();
        } else {
          event.finish();
        }
        "step 2";
        target.draw(target.maxHp - target.hp);
      },
      ai: {
        expose: 0.3,
        result: {
          target: function(player, target) {
            var eff = ai.get.damageEffect(target, player);
            if (target.hp == 1) return eff;
            return target.maxHp - target.hp - 2 + eff;
          }
        },
        order: 5
      }
    },
    swd_xiuluo: {
      trigger: { player: "phaseBegin" },
      direct: true,
      filter: function(event, player) {
        return player.num("j") > 0;
      },
      content: function() {
        "step 0";
        player.chooseToDiscard(2, "hj", function(card) {
          if (ui.selected.cards.length == 0) return true;
          if (get.position(ui.selected.cards[0]) == "h") {
            if (get.position(card) != "j") return false;
          }
          if (get.position(ui.selected.cards[0]) == "j") {
            if (get.position(card) != "h") return false;
          }
          return get.suit(card) == get.suit(ui.selected.cards[0]);
        }, "是否一张手牌来弃置一张花色相同的判定牌？").ai = function(card) {
          if (get.position(card) == "h") {
            return 11 - ai.get.value(card);
          }
          if (card.name == "lebu") return 5;
          if (card.name == "bingliang") return 4;
          if (card.name == "guiyoujie") return 3;
          return 2;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("swd_xiuluo");
        }
      }
    },
    guxing: {
      group: ["guxing1", "guxing3"]
    },
    guxing1: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        var min = Math.max(1, player.maxHp - player.hp);
        return player.num("h") <= min && player.num("h") > 0 &&
          lib.filter.filterCard({ name: "sha" }, player);
      },
      filterCard: true,
      selectCard: -1,
      // viewAs:{name:'sha'},
      discard: false,
      prepare: function(cards, player, targets) {
        player.$throw(cards);
        player.line(targets);
      },
      filterTarget: function(card, player, target) {
        return lib.filter.targetEnabled({ name: "sha" }, player, target);
      },
      content: function() {
        "step 0";
        delete player.storage.guxing;
        targets.sort(lib.sort.seat);
        player.useCard({ name: "sha" }, cards, targets, "guxing").animate = false;
        "step 1";
        if (player.storage.guxing) {
          player.draw(player.storage.guxing);
          delete player.storage.guxing;
        }
      },
      multitarget: true,
      selectTarget: [1, 3],
      ai: {
        order: function() {
          if (_status.event.player.num("h") == 1) return 10;
          return lib.card.sha.ai.order + 0.1;
        },
        result: {
          target: function(player, target) {
            return ai.get.effect(target, { name: "sha" }, player, target);
          }
        },
        threaten: function(player, target) {
          if (target.hp < target.maxHp - 1) return 1.5;
        }
      }
    },
    guxing3: {
      trigger: { source: "damageAfter" },
      forced: true,
      popup: false,
      filter: function(event) {
        return event.parent.skill == "guxing";
      },
      content: function() {
        if (!player.storage.guxing) {
          player.storage.guxing = 1;
        } else {
          player.storage.guxing++;
        }
      }
    },
    miles_xueyi: {
      trigger: { player: "damageBefore" },
      forced: true,
      priority: 10,
      content: function() {
        trigger.untrigger();
        trigger.finish();
        player.loseHp();
      }
    },
    swdxueyi: {
      trigger: { player: "phaseDrawBegin" },
      frequent: true,
      content: function() {
        trigger.num += player.maxHp - player.hp;
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage")) {
              if (target.hp == target.maxHp) return [0, 1];
            }
            if (get.tag(card, "recover") && player.hp >= player.maxHp - 1) return [0, 0];
          }
        }
      }
    },
    jifeng: {
      mod: {
        selectTarget: function(card, player, range) {
          if (range[0] != 1 || range[1] != 1) return;
          var range2 = get.select(get.info(card).selectTarget);
          if (range2[0] != 1 && range2[1] != 1) return;
          if (card.name == "sha" || get.type(card) == "trick") range[1] = Infinity;
        }
      },
      trigger: { player: "useCardToBefore" },
      priority: 6,
      forced: true,
      popup: false,
      filter: function(event, player) {
        if (event.targets.length <= 1) return false;
        if (event.card.name == "sha") return true;
        else if (get.type(event.card) == "trick") {
          var range = get.select(get.info(event.card).selectTarget);
          if (range[0] == 1 && range[1] == 1) return true;
        }
        return false;
      },
      content: function() {
        if (Math.random() > (1.3 + trigger.targets.length / 5) / trigger.targets.length) {
          trigger.target.popup("失误");
          trigger.untrigger();
          trigger.finish();
        }
      }
    },
    mohua2: {
      unique: true,
      trigger: { player: "dying" },
      priority: 10,
      forced: true,
      content: function() {
        "step 0";
        player.removeSkill("miles_xueyi");
        player.removeSkill("aojian");
        player.removeSkill("mohua2");
        player.addSkill("moyan");
        player.addSkill("miedao");
        player.addSkill("jifeng");
        player.addSkill("swd_xiuluo");

        lib.character.swd_satan = ["", "qun", 4, ["moyan", "miedao", "jifeng", "swd_xiuluo"], ["temp"]];
        if (player.name == "swd_miles") player.name = "swd_satan";
        if (player.name1 == "swd_miles") player.name1 = "swd_satan";
        if (player.name2 == "swd_miles") {
          player.name2 = "swd_satan";
          player.node.avatar2.setBackground("swd_satan", "character");
        } else {
          player.node.avatar.setBackground("swd_satan", "character");
        }

        "step 1";
        player.recover(2);
        "step 2";
        player.draw(2);
      }
    },
    liexin: {
      trigger: { source: "damageBegin" },
      direct: true,
      content: function() {
        "step 0";
        player.chooseToDiscard("是否弃置一张牌使伤害+1？", "he").ai = function(card) {
          if (ai.get.attitude(player, trigger.player) < 0) {
            return 7 - ai.get.value(card);
          }
        };
        "step 1";
        if (result.bool) {
          player.logSkill("liexin");
          trigger.num++;
        }
      },
      ai: {
        threaten: 1.8
      }
    },
    mohua: {
      trigger: { player: "dying" },
      priority: 10,
      forced: true,
      mode: ["identity"],
      content: function() {
        "step 0";
        var skills = ["wuying", "xiehun", "jumo"];
        if (lib.config.mode_choice.double_character) {
          skills.push("swd_xiuluo");
        }
        lib.character.swd_satan = ["", "qun", 6, skills, ["temp"]];
        if (!_status.ai.customAttitude) _status.ai.customAttitude = [];
        _status.ai.customAttitude.push(function(from, to) {
          if (from.storage.xiehun) {
            if (to == game.zhu) return 10;
            return -10;
          }
          if (to.storage.xiehun) {
            return 0;
          }
        });
        player.uninit();
        player.init("swd_satan");
        player.hp = game.players.length;
        player.update();
        game.zhu = player;
        player.identity = "zhu";
        player.setIdentity("魔");
        player.identityShown = true;
        var players = get.players(false, true);
        for (var i = 0; i < players.length; i++) {
          if (players[i] != player) {
            players[i].identity = "fan";
            players[i].setIdentity("人");
            players[i].identityShown = true;
          }
        }
        player.draw(2);
        "step 1";
        while (_status.event.name != "phaseLoop") {
          _status.event = _status.event.parent;
        }
        _status.event.player = player;
        _status.event.step = 0;
        ui.clear();
      }
    },
    wuying: {
      mod: {
        selectTarget: function(card, player, range) {
          if (card.name == "sha") {
            range[0] = -1;
            range[1] = -1;
          }
          if (get.type(card) == "trick" && range[0] == 1 & range[1] == 1) {
            range[0] = -1;
            range[1] = -1;
          }
        }
      }
    },
    xiehun: {
      group: ["xiehun1", "xiehun2"],
      intro: {
        content: "已陷入混乱状态",
        show: true
      }
    },
    xiehun1: {
      trigger: { player: "phaseBegin" },
      forced: true,
      popup: false,
      content: function() {
        if (game.me.storage.xiehun) ui.auto.show();
        for (var i = 0; i < game.players.length; i++) {
          delete game.players[i].storage.xiehun;
        }
        if (ui.auto.innerHTML == "托管") _status.auto = false;
      }
    },
    xiehun2: {
      trigger: { source: "damageBegin" },
      filter: function(event, player) {
        return event.player != player;
      },
      forced: true,
      content: function() {
        trigger.player.storage.xiehun = true;
        if (trigger.player == game.me) {
          _status.auto = true;
          ui.auto.hide();
        }
        // player.chooseToDiscard(true,'h');
      }
    },
    jumo2: {
      trigger: { player: "phaseDrawBegin" },
      forced: true,
      priority: -10,
      content: function() {
        var num = Math.max(2, game.players.length - 1);
        if (lib.config.mode_choice.double_character) {
          num++;
        }
        trigger.num = Math.min(4, num);
      }
    },
    jumo: {
      trigger: { player: "phaseEnd" },
      forced: true,
      content: function() {
        var num = 0;
        for (var i = 0; i < game.players.length; i++) {
          if (player != game.players[i] && !game.players[i].storage.xiehun) num++;
        }
        num = 2 * num - game.players.length;
        if (get.config("double_character")) {
          num++;
        }
        if (num > 0) {
          player.draw(num);
        }
      }
    },
    duijue: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return !player.storage.duijue;
      },
      filterTarget: function(card, player, target) {
        return player != target && target != game.zhu;
      },
      content: function() {
        var players = game.players.concat(game.dead);
        players.remove(player);
        players.remove(target);
        for (var i = 0; i < players.length; i++) {
          players[i].classList.add("out");
          players[i].storage.duijue2 = true;
        }
        player.addSkill("duijue2");
        target.addSkill("duijue2");
        player.storage.duijue = true;
      },
      init: function(player) {
        player.storage.duijue = false;
      },
      intro: {
        content: "limited"
      }
    },
    duijue2: {
      trigger: { global: "dieAfter" },
      forced: true,
      popup: false,
      content: function() {
        var players = game.players.concat(game.dead);
        for (var i = 0; i < players.length; i++) {
          if (players[i].storage.duijue2 && players[i].isOut()) {
            players[i].classList.remove("out");
            delete players[i].storage.duijue2;
          }
          players[i].removeSkill("duijue2");
        }
      }
    },
    yueren: {
      trigger: { player: "shaBegin" },
      filter: function(event, player) {
        return !player.skills.contains("yueren2");
      },
      check: function(event, player) {
        return ai.get.attitude(player, event.target) <= 0;
      },
      content: function() {
        "step 0";
        player.judge(function() {
          return 0;
        });
        player.addTempSkill("yueren2", "phaseAfter");
        "step 1";
        if (get.color(result.card) == "black") {
          if (trigger.target.num("he")) {
            player.discardPlayerCard(true, trigger.target, "he");
            // trigger.target.discard(trigger.target.get('he').randomGet());
          }
        } else if (trigger.cards && trigger.cards.length) {
          player.gain(trigger.cards);
          player.$gain2(trigger.cards);
          game.log(get.translation(player) + "收回了" + get.translation(trigger.cards));
        }
      }
    },
    yueren2: {},
    busi: {
      unique: true,
      global: "busi2"
    },
    busi2: {
      trigger: { player: "phaseAfter" },
      forced: true,
      popup: false,
      content: function() {
        var target = player.nextSeat;
        while (target.isDead() && target.skills.contains("busi") == false) {
          target = target.nextSeat;
        }
        if (target.isDead()) {
          target.revive(1);
          target.classList.add("turnedover");
          target.logSkill("busi");
        }
      },
      ai: {
        threaten: 0.5
      }
    },
    xuying: {
      unique: true,
      trigger: { player: "damageBefore" },
      forced: true,
      content: function() {
        trigger.untrigger();
        trigger.finish();
        if (player.num("h")) player.loseHp();
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (get.tag(card, "damage") && target.num("h") == 0) return 0;
          }
        }
      }
    },
    yinguo: {
      unique: true,
      trigger: { global: "damageBefore" },
      priority: 6,
      direct: true,
      filter: function(event, player) {
        if (event.player == player || event.source == player) return false;
        if (!event.source) return false;
        if (player.num("he") == 0) return false;
        if (player.skills.contains("yinguo2")) return false;
        return true;
      },
      content: function() {
        "step 0";
        var go = ai.get.attitude(player, trigger.player) > 0 && ai.get.attitude(player, trigger.source) < 0;
        player.chooseToDiscard("是否将伤害来源（" + get.translation(trigger.source) +
          "）和目标（" + get.translation(trigger.player) + "）对调？", "he").ai = function(card) {
          if (go) {
            return 10 - ai.get.value(card);
          }
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("yinguo");
          var target = trigger.player;
          trigger.player = trigger.source;
          trigger.source = target;
          trigger.trigger("damageBefore");
          player.addTempSkill("yinguo2", ["damageAfter", "damageCancelled"]);
        }
      },
      ai: {
        threaten: 10,
        expose: 0.5
      },
      global: "yinguo3"
    },
    yinguo2: {},
    yinguo3: {
      ai: {
        effect: {
          target: function(card, player, target) {
            if (!get.tag(card, "damage")) return;
            if (target.skills.contains("yinguo")) return;
            var source = null;
            for (var i = 0; i < game.players.length; i++) {
              if (game.players[i].skills.contains("yinguo")) {
                source = game.players[i];
                break;
              }
            }
            if (source && source.num("he")) {
              if (ai.get.attitude(player, source) < 0 && ai.get.attitude(player, target) < 0) {
                return [0, 0, 0, -1];
              }
            }
          }
        }
      }
    },
    guiyan: {
      unique: true,
      enable: "phaseUse",
      usable: 1,
      intro: {
        content: ""
      },
      mark: true,
      filterTarget: function(card, player, target) {
        return player != target && target.num("h");
      },
      content: function() {
        "step 0";
        player.chooseCardButton(target, target.get("h")).filterButton = function(button) {
          return get.suit(button.link) == "club";
        };
        "step 1";
        if (result.bool) {
          player.gain(result.links[0]);
          target.$give(1, player);
          game.delay(0, 500);
        }
      },
      ai: {
        order: 11,
        result: {
          target: -1,
          player: 1
        },
        threaten: 1.3
      },
      group: ["guiyan2"]
    },
    guiyan2: {
      trigger: { player: "dying" },
      priority: 6,
      forced: true,
      content: function() {
        player.recover();
        player.removeSkill("guiyan");
        player.removeSkill("guiyan2");
      }
    },
    yunshen_old: {
      mod: {
        globalFrom: function(from, to, distance) {
          if (!from.get("e", "1")) return distance - 1;
        },
        globalTo: function(from, to, distance) {
          if (!to.get("e", "2")) return distance + 1;
        }
      }
    },
    suiyan_old: {
      enable: "phaseUse",
      usable: 1,
      filterCard: function(card) {
        return get.type(card) == "basic";
      },
      filterTarget: function(card, player, target) {
        return player != target && target.num("e");
      },
      content: function() {
        var num = Math.floor(Math.random() * 3);
        if (num == 0) {
          player.draw();
        } else {
          target.discard(target.get("e").sort(lib.sort.random).splice(0, num));
        }
      },
      ai: {
        order: 7,
        result: {
          target: -1
        },
        threaten: 1.2
      }
    },
    xianyin: {
      enable: "phaseUse",
      filter: function(event, player) {
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].num("j") && game.players[i] != player) return true;
        }
        return false;
      },
      content: function() {
        "step 0";
        event.targets = [];
        for (var i = 0; i < game.players.length; i++) {
          if (game.players[i].num("j") && game.players[i] != player) {
            // game.players[i].gain(game.players[i].get('j'),'gain2');
            event.targets.add(game.players[i]);
          }
        }
        event.targets.sort(lib.sort.seat);
        "step 1";
        if (event.targets.length) {
          event.target = event.targets.shift();
          event.target.discard(event.target.get("j"));
        } else {
          event.finish();
        }
        "step 2";
        if (event.target.num("h")) {
          event.target.chooseCard("选择一张手牌交给" + get.translation(player), true).ai = function(card) {
            return -ai.get.value(card);
          };
        } else {
          event.goto(1);
        }
        "step 3";
        if (result.bool) {
          player.gain(result.cards[0]);
          target.$give(1, player);
        }
        event.goto(1);
      },
      ai: {
        order: 9,
        result: {
          player: function(player) {
            var num = 0;
            for (var i = 0; i < game.players.length; i++) {
              if (game.players[i] != player && game.players[i].num("j")) {
                if (ai.get.attitude(player, game.players[i]) >= 0 &&
                  ai.get.attitude(game.players[i], player) >= 0) {
                  num++;
                } else {
                  num--;
                }
              }
            }
            return num;
          }
        }
      }
    },
    mailun: {
      unique: true,
      trigger: { player: "phaseBegin" },
      direct: true,
      intro: {
        content: function(storage) {
          if (!storage) return "无";
          return lib.skill.mailun.effects[storage - 1];
        }
      },
      effects: [
        "减少一点体力并增加一点体力上限",
        "增加一点体力并减少一点体力上限",
        "令你即将造成和即将受到的首次伤害-1",
        "令你即将造成和即将受到的首次伤害+1",
        "少摸一张牌并令手牌上限+1",
        "多摸一张牌并令手牌上限-1",
        "进攻距离+1，防御距离-1",
        "进攻距离-1，防御距离+1"
      ],
      content: function() {
        "step 0";
        player.removeSkill("mailun31");
        player.removeSkill("mailun32");
        player.removeSkill("mailun41");
        player.removeSkill("mailun42");
        player.removeSkill("mailun5");
        player.removeSkill("mailun6");
        player.removeSkill("mailun7");
        player.removeSkill("mailun8");
        if (event.isMine()) {
          ui.auto.hide();
          event.dialog = ui.create.dialog("选择一个效果");
          var effects = lib.skill.mailun.effects;
          var clickItem = function() {
            event.choice = this.link;
            game.resume();
          };
          for (var i = 0; i < 8; i++) {
            if (i == 0 && player.maxHp == 6) continue;
            var item = event.dialog.add("<div class=\"popup\" style=\"width:70%;display:inline-block\"><div class=\"skill\">【" +
              get.cnNumber(i + 1, true) + "轮" + "】</div><div>" + effects[i] + "</div></div>");
            item.addEventListener("click", clickItem);
            item.link = i + 1;

          }
          event.control = ui.create.control("取消", function() {
            event.choice = 0;
            game.resume();
          });
          event.dialog.add(ui.create.div(".placeholder"));
          event.dialog.add(ui.create.div(".placeholder"));
          event.dialog.add(ui.create.div(".placeholder"));
          game.pause();
        } else {
          var ctrl;
          if (player.hp <= 1) {
            if (player.maxHp > 3) {
              ctrl = 2;
            } else {
              ctrl = 3;
            }
          } else if (player.hp == 2) {
            if (player.maxHp > 4) {
              ctrl = 2;
            } else if (player.num("h") == 0) {
              ctrl = 6;
            } else {
              ctrl = 3;
            }
          } else if (player.num("h") < player.hp) {
            ctrl = 6;
          } else if (player.num("h") > player.hp + 1) {
            ctrl = 5;
          }
          event.choice = ctrl;
        }
        "step 1";
        ui.auto.show();
        player.storage.mailun = event.choice;
        if (event.choice) {
          player.logSkill("mailun");
          player.markSkill("mailun");
          switch (event.choice) {
            case 1: {
              player.loseHp();
              player.gainMaxHp();
              break;
            }
            case 2: {
              player.recover();
              player.loseMaxHp();
              break;
            }
            case 3: {
              player.addSkill("mailun31");
              player.addSkill("mailun32");
              break;
            }
            case 4: {
              player.addSkill("mailun41");
              player.addSkill("mailun42");
              break;
            }
            case 5: {
              player.addSkill("mailun5");
              break;
            }
            case 6: {
              player.addSkill("mailun6");
              break;
            }
            case 7: {
              player.addSkill("mailun7");
              break;
            }
            case 8: {
              player.addSkill("mailun8");
              break;
            }
          }
        } else {
          player.unmarkSkill("mailun");
        }

        if (event.dialog) {
          event.dialog.close();
        }
        if (event.control) {
          event.control.close();
        }
      }
    },
    mailun31: {
      trigger: { source: "damageBegin" },
      forced: true,
      content: function() {
        trigger.num--;
        player.removeSkill("mailun31");
      }
    },
    mailun32: {
      trigger: { player: "damageBegin" },
      forced: true,
      content: function() {
        trigger.num--;
        player.removeSkill("mailun32");
      }
    },
    mailun41: {
      trigger: { source: "damageBegin" },
      forced: true,
      content: function() {
        trigger.num++;
        player.removeSkill("mailun41");
      }
    },
    mailun42: {
      trigger: { player: "damageBegin" },
      forced: true,
      content: function() {
        trigger.num++;
        player.removeSkill("mailun42");
      }
    },
    mailun5: {
      trigger: { player: "phaseDrawBegin" },
      forced: true,
      popup: false,
      content: function() {
        trigger.num--;
      },
      mod: {
        maxHandcard: function(player, num) {
          return num + 1;
        }
      }
    },
    mailun6: {
      trigger: { player: "phaseDrawBegin" },
      forced: true,
      popup: false,
      content: function() {
        trigger.num++;
      },
      mod: {
        maxHandcard: function(player, num) {
          return num - 1;
        }
      }
    },
    mailun7: {
      mod: {
        globalFrom: function(from, to, distance) {
          return distance - 1;
        },
        globalTo: function(from, to, distance) {
          return distance - 1;
        }
      }
    },
    mailun8: {
      mod: {
        globalFrom: function(from, to, distance) {
          return distance + 1;
        },
        globalTo: function(from, to, distance) {
          return distance + 1;
        }
      }
    },
    fengming: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("he", { type: "equip" }) > 0;
      },
      filterCard: { type: "equip" },
      position: "he",
      filterTarget: true,
      content: function() {
        "step 0";
        target.recover();
        "step 1";
        target.draw();
      },
      ai: {
        order: 9,
        result: {
          target: function(player, target) {
            if (target.hp < target.maxHp) {
              return ai.get.recoverEffect(target);
            }
          }
        }
      }
    },
    wanjun: {
      enable: "chooseToUse",
      filter: function(event, player) {
        return player.num("he", { type: "equip" }) > 0;
      },
      filterCard: function(card) {
        return get.type(card) == "equip";
      },
      position: "he",
      viewAs: { name: "nanman" },
      prompt: "将一张装备牌当南蛮入侵使用",
      check: function(card) {
        var player = _status.currentPhase;
        if (player.num("he", { subtype: get.subtype(card) }) > 1) {
          return 11 - ai.get.equipValue(card);
        }
        if (player.num("h") < player.hp) {
          return 6 - ai.get.value(card);
        }
        return 2 - ai.get.equipValue(card);
      },
      ai: {
        order: 9,
        threaten: 1.1
      }
    },
    huanling: {
      trigger: { player: "phaseEnd" },
      direct: true,
      content: function() {
        "step 0";
        player.chooseTarget("是否发动【幻灵】？", function(card, player, target) {
          return player != target;
        }).ai = function(target) {
          var att = ai.get.attitude(player, target);
          if (target.isTurnedOver()) {
            if (att > 0) {
              return att + 5;
            }
            return -1;
          }
          if (player.isTurnedOver()) {
            return 5 - att;
          }
          return -att;
        };
        "step 1";
        if (result.bool) {
          player.discard(result.cards);
          player.logSkill("huanling", result.targets);
          player.turnOver();
          result.targets[0].turnOver();
        }
      },
      group: "huanling2",
      ai: {
        effect: {
          target: function(card, player, target, current) {
            if (card.name == "guiyoujie") return [0, 2];
            if (target.isTurnedOver()) {
              if (get.tag(card, "damage")) return 0;
            }
          }
        },
        expose: 0.2
      }
    },
    huanling2: {
      trigger: { player: "damageBefore" },
      filter: function(event, player) {
        return player.isTurnedOver();
      },
      forced: true,
      content: function() {
        trigger.untrigger();
        trigger.finish();
      }
    },
    ljifeng: {
      trigger: { player: "phaseUseBefore" },
      direct: true,
      filter: function(event, player) {
        return player.num("h") > 0;
      },
      content: function() {
        "step 0";
        var check = player.num("h") <= player.hp + (player.hp > 2 ? 2 : 1);
        player.chooseCardTarget({
          prompt: "是否发动【疾风】？",
          filterCard: true,
          filterTarget: function(card, player, target) {
            if (player == target) return false;
            return player.canUse({ name: "sha" }, target, false);
          },
          selectTarget: [1, 2],
          ai1: function(card) {
            if (!check) return 0;
            return 8 - ai.get.value(card);
          },
          ai2: function(target) {
            if (!check) return 0;
            return ai.get.effect(target, { name: "sha" }, player);
          }
        });
        "step 1";
        if (result.bool) {
          player.logSkill("ljifeng", result.targets);
          player.discard(result.cards);
          player.useCard({ name: "sha" }, result.targets).animate = false;
          trigger.untrigger();
          trigger.finish();
        }
      }
    },
    lxianglong: {
      trigger: { target: "shaMiss" },
      priority: 5,
      direct: true,
      content: function() {
        "step 0";
        player.chooseTarget(function(card, player, target) {
          return player.canUse(trigger.card, target);
        }, "是否发动【翔龙】？").ai = function(target) {
          return ai.get.effect(target, trigger.card, player);
        };
        "step 1";
        if (result.bool) {
          player.logSkill("lxianglong");
          player.line(result.targets);
          player.useCard(trigger.card, trigger.cards, result.targets).animate = false;
        }
      },
      ai: {
        effect: {
          target: function(card, player, target) {
            if (card.name == "sha" && target.num("h")) return 0.7;
          }
        }
      }
    },
    zhenjiu: {
      enable: "phaseUse",
      usable: 1,
      filterCard: { color: "red" },
      filterTarget: function(card, player, target) {
        return !target.skills.contains("zhenjiu2");
      },
      check: function(card) {
        return 8 - ai.get.value(card);
      },
      discard: false,
      prepare: function(cards, player, targets) {
        player.$give(cards, targets[0]);
      },
      content: function() {
        "step 0";
        game.delay();
        "step 1";
        target.storage.zhenjiu2 = cards[0];
        target.addSkill("zhenjiu2");
      },
      ai: {
        result: {
          target: function(player, target) {
            if (target.hp < target.maxHp) {
              return target == player ? 1 : 1.5;
            }
            if (player.num("h") > player.hp) return 0.5;
            return 0;
          }
        },
        order: 9,
        threaten: 1.7
      }
    },
    zhenjiu2: {
      trigger: { player: "phaseBegin" },
      forced: true,
      mark: "card",
      content: function() {
        player.recover();
        player.gain(player.storage.zhenjiu2, "gain2");
        game.log(get.translation(player) + "获得了" + get.translation(player.storage.zhenjiu2));
        player.removeSkill("zhenjiu2");
        delete player.storage.zhenjiu2;
      },
      intro: {
        content: "card"
      }
    },
    mazui: {
      enable: "phaseUse",
      usable: 1,
      filterCard: { color: "black" },
      filterTarget: function(card, player, target) {
        return !target.skills.contains("mazui2");
      },
      check: function(card) {
        return 6 - ai.get.value(card);
      },
      discard: false,
      prepare: function(cards, player, targets) {
        player.$give(cards, targets[0]);
      },
      content: function() {
        "step 0";
        game.delay();
        "step 1";
        target.storage.mazui2 = cards[0];
        target.addSkill("mazui2");
      },
      ai: {
        expose: 0.2,
        result: {
          target: function(player, target) {
            return -target.hp;
          }
        },
        order: 4,
        threaten: 1.2
      }
    },
    mazui2: {
      trigger: { source: "damageBegin" },
      forced: true,
      mark: "card",
      filter: function(event) {
        return event.num > 0;
      },
      content: function() {
        trigger.num--;
        player.addSkill("mazui3");
        player.removeSkill("mazui2");
      },
      intro: {
        content: "card"
      }
    },
    mazui3: {
      trigger: { source: "damageEnd" },
      forced: true,
      popup: false,
      content: function() {
        player.gain(player.storage.mazui2, "gain2");
        game.log(get.translation(player) + "获得了" + get.translation(player.storage.mazui2));
        player.removeSkill("mazui3");
        delete player.storage.mazui2;
      }
    },
    shoulie: {
      trigger: { player: "shaBegin" },
      direct: true,
      content: function() {
        "step 0";
        var dis = trigger.target.num("h", "shan") || trigger.target.num("e", "bagua") || trigger.target.num("h") > 2;
        player.chooseToDiscard("是否发动【狩猎】？").ai = function(card) {
          if (dis) return 7 - ai.get.value(card);
          return 0;
        };
        "step 1";
        if (result.bool) {
          player.logSkill("shoulie");
          trigger.directHit = true;
        }
      }
    },
    hudun: {
      trigger: { source: "damageEnd" },
      forced: true,
      filter: function(event, player) {
        return !player.storage.hudun;
      },
      content: function() {
        player.storage.hudun = true;
        player.markSkill("hudun");
      },
      init: function(player) {
        player.storage.hudun = false;
      },
      intro: {
        content: function(st) {
          if (st) return "已开启";
          return "未开启";
        }
      },
      group: "hudun2"
    },
    hudun2: {
      trigger: { player: "damageBegin" },
      forced: true,
      filter: function(event, player) {
        return event.num > 0 && player.storage.hudun;
      },
      content: function() {
        trigger.num--;
        player.storage.hudun = false;
        player.unmarkSkill("hudun");
      }
    },
    toudan: {
      enable: "phaseUse",
      usable: 1,
      filter: function(event, player) {
        return player.num("he", { suit: "spade" });
      },
      filterTarget: function(card, player, target) {
        return player != target;
      },
      filterCard: { suit: "spade" },
      check: function(card) {
        return 10 - ai.get.value(card);
      },
      position: "he",
      line: "fire",
      content: function() {
        "step 0";
        target.damage("fire");
        event.targets = [];
        for (var i = 0; i < game.players.length; i++) {
          if (get.distance(target, game.players[i]) <= 1) {
            event.targets.push(game.players[i]);
          }
        }
        lib.tempSortSeat = event.target;
        event.targets.sort(lib.sort.seat);
        delete lib.tempSortSeat;
        "step 1";
        if (event.targets.length) {
          var current = event.targets.shift();
          if (current.num("he")) {
            current.chooseToDiscard("he", true);
          }
          event.redo();
        }
      },
      ai: {
        result: {
          target: function(player, target) {
            return ai.get.damageEffect(target, player, target, "fire");
          }
        },
        order: 10,
        threaten: 1.5
      }
    },
    shending: {
      inherit: "longfan",
      filter: function(event, player) {
        return !player.get("e", "5");
      },
      ai: {
        order: 11,
        result: {
          player: 1
        },
        effect: {
          target: function(card, player, target) {
            if (player != target) return;
            if (get.subtype(card) == "equip5") {
              if (ai.get.equipValue(card) <= 7) return 0;
            }
          }
        },
        threaten: 1.2
      }
    },
    poxiao: {
      mod: {
        attackFrom: function(from, to, distance) {
          if (!from.get("e", "1")) return distance - 1;
        },
        selectTarget: function(card, player, range) {
          if (!player.get("e", "1") && card.name == "sha") range[1]++;
        }
      },
      enable: "chooseToUse",
      filterCard: { type: "equip" },
      filter: function(event, player) {
        return player.num("he", { type: "equip" });
      },
      position: "he",
      viewAs: { name: "sha" },
      prompt: "将一张闪当杀使用或打出",
      check: function(card) {
        if (get.subtype(card) == "equip1") return 10 - ai.get.value(card);
        return 7 - ai.get.equipValue(card);
      },
      ai: {
        order: function() {
          return lib.card.sha.ai.order + 0.1;
        },
        effect: {
          target: function(card, player) {
            if (get.subtype(card) == "equip1") {
              var num = 0;
              for (var i = 0; i < game.players.length; i++) {
                if (ai.get.attitude(player, game.players[i]) < 0) {
                  num++;
                  if (num > 1) return [0, 0, 0, 0];
                }
              }
            }
          }
        }
      }
    },
    zhexian: {
      inherit: "lingbo"
    }
  },
  translate: {
    swd_yangshuo: "杨硕",
    swd_septem: "赛特",
    swd_yuxiaoxue: "于小雪",
    swd_lilian: "莉莲",
    swd_cheyun: "车芸",
    swd_jipeng: "疾鹏",
    swd_muyun: "徐暮云",
    swd_zhaoyun: "皇甫朝云",
    swd_jiliang: "姬良",
    swd_lanyin: "兰茵",
    swd_zhiyin: "芝茵",
    swd_hengai: "横艾",
    swd_huzhongxian: "壶中仙",
    swd_qiner: "磬儿",
    swd_huanyuanzhi: "桓远之",
    swd_murongshi: "慕容诗",
    swd_hupo: "琥珀",
    swd_miles: "麦尔斯",
    swd_kangnalishi: "康那里士",
    swd_satan: "撒旦",
    swd_philis: "菲力斯",
    swd_weida: "薇达",
    swd_fengtianling: "凤天凌",
    swd_huyue: "瑚月",
    swd_jiting: "姬亭",
    swd_rongshuang: "蓉霜",
    swd_zhuoshanzhu: "浊山铸",
    swd_jialanduo: "迦兰多",
    swd_linming: "林明",
    swd_duanmeng: "端蒙",
    swd_nicole: "妮可",
    swd_kendi: "肯迪",
    swd_lijing: "李靖",
    swd_hanteng: "韩腾",
    swd_yuwentuo: "宇文拓",
    swd_shanxiaoxiao: "单小小",
    swd_yuchiyanhong: "尉迟嫣红",
    swd_pepin: "丕平",
    swd_anka: "安卡",
    swd_jiangwu: "疆梧",
    swd_situqiang: "司徒蔷",
    swd_tuwei: "徒维",
    swd_yeyaxi: "耶亚希",
    swd_chunyuheng: "淳于恒",
    swd_duguningke: "独孤宁珂",
    swd_duguningke2: "魔化宁珂",
    swd_chenjingchou: "陈靖仇",
    swd_zhanglie: "张烈",
    swd_guyue: "古月圣",
    swd_kama: "卡玛",
    swd_yuli: "玉澧",
    swd_duopeng: "多鹏",
    swd_jiangziya: "姜子牙",
    swd_heran: "何然",
    swd_zhanggao: "张诰",
    swd_hanlong: "韩龙",
    swd_jiuyou: "久悠",
    swd_qingming: "青冥",
    swd_shangzhang: "尚章",
    swd_youzhao: "游兆",
    swd_wangsiyue: "王思月",
    swd_huanglei: "黄雷",
    swd_tuobayuer: "拓跋玉儿",
    swd_tuobayueer: "拓跋月儿",
    swd_chengyaojin: "程咬金",
    swd_qinshubao: "秦叔宝",
    swd_lishimin: "李世民",
    swd_shuijing: "水镜",
    swd_xuanyuanjianxian: "轩辕剑仙",
    swd_xuanyuanjiantong: "轩辕剑童",
    swd_luchengxuan: "陆承轩",
    swd_xiarou: "夏柔",
    swd_moye: "莫邪",
    swd_fu: "毛民·福",
    swd_hanluo: "寒洛",
    swd_linyue: "临月",
    swd_zidashu: "子大暑",
    swd_maixing: "麦星",
    swd_haidapang: "海大胖",
    swd_shaowei: "少微",
    swd_fuyan: "符验",
    swd_huiyan: "慧彦",
    swd_sikongyu: "司空宇",
    swd_muyue: "沐月",
    swd_ziqiao: "子巧",
    swd_fengyu: "凤煜",
    swd_qi: "柒",
    swd_chenfu: "陈辅",
    swd_libai: "李白",
    swd_xingtian: "刑天",
    swd_lanmoshen: "蓝魔神",
    swd_wushi: "巫师",

    miaobi: "妙笔",
    miaobi_info: "出牌阶段限一次，你可以将一张红桃牌当作五谷丰登使用",
    zhexian: "谪仙",
    jufu: "巨斧",
    jufu_info: "锁定技，当你有武器牌时，杀造成的伤害+1",
    huajing: "化精",
    huajing_info: "每当你使用锦囊牌造成伤害，可以回复一点体力",
    pingxu: "冯虚",
    pingxu_info: "锁定技，当你没有武器牌时，与其他角色的距离-1；当你没有防具牌时，其他角色与你的距离+1",
    yudun: "愚钝",
    yudun_info: "锁定技，你的锦囊牌均视为杀，你于回合内使用的杀无数量限制",
    bingfeng: "冰封",
    bingfeng2: "冰封",
    bingfeng2_info: "不能使用或打出手牌",
    bingfeng_info: "限定技，出牌阶段，你可以指定至多三个目标与其一同翻面，且处于翻面状态时不能使用或打出手牌；若如此做，你失去技能玄咒并减少一点体力上限",
    guozao: "聒噪",
    guozao_info: "锁定技，每当距离你1以内的角色受到一次伤害，若伤害来源不你，你须观看牌堆顶的三张牌，然后指定一名有手牌的角色将手牌与这些牌交换",
    heihuo: "黑火",
    heihuo_info: "出牌阶段，你可以弃置一张装备牌，令你的手牌数加倍；若你的手牌因此达到10张或更多，你立即受到3点火焰伤害且本回合内不能再次发动黑火",
    yaotong: "妖瞳",
    yaotong1: "妖瞳",
    yaotong2: "妖瞳",
    yaotong3: "妖瞳",
    yaotong4: "妖瞳",
    yaotong_info: "当你的手牌数为奇数时，你可以将一张手牌当作杀或闪使用或打出，当你的手牌数为偶数时，你可以将一张手牌当作无懈可击使用",
    pojian: "破茧",
    pojian_info: "每当你失去最后一张手牌，可以从牌堆中获得一张装备牌并装备之",
    kuangfu: "狂斧",
    kuangfu_info: "每当你使用杀造成伤害，可以将对方的一张装备牌移到你的装备区",
    huajin: "化金",
    huajin2: "化金",
    huajin_info: "出牌阶段限一次，你可以弃置一张牌令你造成的伤害+1，直到你的下一回合开始",
    poxiao: "破霄",
    poxiao_info: "你可以将一张装备牌当杀使用；当你没有武器牌时，你的攻击范围+1，杀可以额外指定一个目标",
    jianji: "箭疾",
    jianji_info: "你可以将一张装备牌当杀使用，然后摸一张牌，此杀无视距离和防具，且不计入回合内出杀限制",
    yuchen: "浴尘",
    yuchen_info: "每当你于回合外使用或打出一张黑色牌，你可以弃置一名角色的一张牌",
    huangyu: "凰羽",
    huangyu_info: "出牌阶段限一次，你可以将两张红色牌当炽羽袭使用",
    bingjian: "冰箭",
    bingjian_info: "出牌阶段限一次，你可以弃置一张黑色的杀，令一名有手牌的其他角色展示手牌并弃置其中的所有闪，若其没有闪则受到一点雷电伤害",
    rumeng: "入梦",
    rumeng_info: "其他角色的出牌阶段前，你可以弃置一张非基本牌，并令其选择一项：弃置一张基本牌，或跳过出牌及弃牌阶段",
    lianda: "连打",
    lianda_info: "当你使用一杀结算完毕后，可以弃置一张牌视为对目标再使用一张杀",
    xianghui: "祥晖",
    xianghui_info: "出牌阶段限一次，你可以弃置一张红色手牌，然后令场上体力值最少的角色各回复一点体力",
    huiqi: "回气",
    huiqi_info: "每当你的体力值减少，可令一名角色摸X张牌，X为你已损失的体力值且最多为3",
    toudan: "投弹",
    toudan_info: "出牌阶段限一次，你可以弃置一张黑桃牌对一名其他角色造成一点火焰伤害，然后令距离该角色1以内的所有角色弃置一张牌",
    shending: "神丁",
    shending_info: "锁定技，若你没有宝物牌，视为装备了蓝格怪衣",
    hzhenwei: "镇卫",
    hzhenwei_info: "当一名其他角色成为杀的目标后，若你在杀的使用者的攻击范围内，你可以弃置一张牌将此杀转移给自己，并在杀结算完毕后摸一张牌",
    shoulie: "狩猎",
    shoulie_info: "当你使用一张杀指定目标后，可以弃置一张手牌令此杀不可闪避",
    hudun: "护盾",
    hudun_bg: "盾",
    hudun2: "护盾",
    hudun_info: "锁定技，当你造成一次伤害后，受到的下一次伤害-1",
    mazui: "麻醉",
    mazui2: "麻醉",
    mazui_info: "出牌阶段限一次，你可以将一张黑色手牌置于一名角色的武将牌上，该角色造成的下一次伤害-1，然后获得此牌",
    zhenjiu: "针灸",
    zhenjiu2: "针灸",
    zhenjiu_info: "出牌阶段限一次，你可以将一张红色手牌置于一名角色的武将牌上，该角色于下一个回合开始阶段回复一点体力，然后获得此牌",
    ljifeng: "疾风",
    ljifeng_info: "你可以弃置一张手牌并跳过出牌阶段，视为对至多两名角色使用一张杀",
    lxianglong_info: "每当你闪避一张杀，可以将此杀对攻击范围内的一名角色使用",
    lxianglong: "翔龙",
    shangxi: "伤袭",
    shangxi_info: "回合开始阶段，你可以弃置一张牌，并对攻击范围内一名体力值不小于你的其他角色造成一点伤害",
    zhenwei: "镇威",
    zhenwei_info: "你可以将攻击范围内其他角色打出的卡牌交给除该角色外的任意一名角色",
    fuyan: "覆岩",
    fuyan2: "覆岩",
    fuyan_info: "每当你受到一次伤害，可以摸一张牌，并将一张牌置于一名角色的武将牌上称为“岩”；当其受到伤害时，须将“岩”置于弃牌堆，然后令伤害-1",
    guaili: "怪力",
    guaili_info: "锁定技，你的杀造成的伤害+1",
    pingshen: "凭神",
    pingshen2: "凭神",
    pingshen_info: "锁定技，受到过你的伤害的角色可在回合内对你发动一次【离魂】（每局限发动一次）",
    xingzhui: "星坠",
    xingzhui_info: "出牌阶段限一次，你可以弃置一张牌，并选择一名角色令其弃置一张牌，若其弃置的牌类别与你不同，其受到一点伤害",
    lingxian: "凌仙",
    lingxian_info: "每当你于回合外使用或打出一张手牌，你可以选择攻击范围外的一名其他角色与你各摸一张牌",
    shouyin: "守印",
    shouyin_info: "限定技，当任意一名角色处于濒死状态时，若你的武将牌正朝上，可以将武将牌翻面，然后令场上所有存活角色将体力回复至体力上限",
    bofeng: "搏风",
    bofeng_info: "锁定技，体力值不大于你的角色视为在你的攻击范围；当你使用杀指定目标时，可令目标额外打出一张闪，否则此杀不可闪避且造成的伤害+1",
    hutian: "护天",
    hutian2: "护天",
    hutian3: "护天",
    hutian_info: "回合结束阶段，你可以将X张牌置于一名角色的武将牌上，则该角色的体力值始终不能小于X；在你的下一个回合结束阶段，该角色获得武将牌上的牌（在此回合不能再次发动）",
    linyun: "凌云",
    linyun_info: "你可以将两张牌当作杀使用，此杀需要额外一张闪才能闪避；若此杀造成伤害，你摸一张牌",
    sliufeng: "流风",
    sliufeng_info: "锁定技，体力值不大于你的角色视为在你的攻击范围",
    chengjian: "承剑",
    chengjian_info: "每当其他角色使用杀造成一次伤害，你可以令其摸一张牌",
    huanling: "幻灵",
    huanling2: "幻灵",
    huanling_info: "回合结束阶段，你可以选择一名角色与你同时翻面；翻面状态下，你防止一切伤害",
    xiaozhan: "消战",
    xiaozhan_info: "其他角色使用杀时，若你不是杀的目标，可以弃置一张杀取消之",
    xielei: "挟雷",
    xielei_info: "每当你使用或打出一张杀，可立即对一名目标以外的角色造成一点雷电伤害",
    dangping: "荡平",
    dangping_info: "每当你造成一次伤害，可以弃置一张手牌对其距离1以内的另一名角色造成一点伤害",
    guisi: "归思",
    guisi_info: "每当你成为杀的目标，你可以交给对方一张手牌并取消之",
    duishi: "对诗",
    duishi_info: "出牌阶段限一次，你可以弃置一张手牌，并指定一名角色弃置一张与之花色相同的手牌，否则你获得其一张牌",
    anlianying: "连营",
    anlianying_info: "每当你失去最后一张手牌，可摸两张牌",
    lianwu: "连舞",
    lianwu_info: "锁定技，你的杀可以额外指定一个目标，你的红杀不可被闪避",
    jiying: "疾鹰",
    jiying_info: "锁定技，你使用杀无视距离",
    daofa: "道法",
    daofa_info: "每当有一名其他角色造成伤害，你可以令其弃置一张牌",
    xiaomoyu: "魔愈",
    xiaomoyu_info: "锁定技，每当你造成一次伤害，你摸一张牌或回复一点体力",
    yihua: "移花",
    yihua_info: "每当你成为其他角色的某张卡牌的惟一目标时，你可以弃置两张手牌，将使用者与目标对调",
    youyin: "游吟",
    youyin_info: "每当有其他角色弃置卡牌时，若其中有基本牌且你的手牌数不超过5，你可以摸一张牌",
    rexue: "热血",
    rexue_info: "任意一名角色的回合开始阶段，你可以对其使用一张杀，然后摸一张牌",
    huopu: "火瀑",
    huopu_info: "你可以将一张红桃手牌当作流星火羽使用",
    benlei: "奔雷",
    benlei2: "奔雷",
    benlei_info: "你可以将三张牌当惊雷闪使用；每当你造成一次雷属性伤害，你回复一点体力",
    lingwu: "灵舞",
    lingwu_info: "回合结束后，若你在本回合内使用了至少3张牌，你可以进行一个额外的回合",
    miejing: "灭境",
    miejing_info: "限制技，你可以弃置所有黑色牌，然后令所有其他角色受到一点雷电伤害",
    lingxin: "灵心",
    lingxin_info: "回合结束阶段，你可以亮出牌堆顶的X+1张牌，然后获得其中的红桃牌，X为你回合内使用的牌数且至少为2",
    fushen: "附身",
    fushen_info: "回合开始前，你可以将自己移出游戏，并代替另一名角色进行一回合，然后流失一点体力",
    fushen2: "附身",
    tiandao: "天道",
    tiandao_info: "任意一名角色的判定生效前，你可以打出一张牌替换之",
    swdqinyin: "琴音",
    swdqinyin_info: "回合结束阶段，若你于本回合内未造成过伤害，你可以令所有角色失去或回复一点体力",
    wangchen: "忘尘",
    wangchen_info: "若你于弃牌阶段弃置了基本牌，可令一名角色翻面",
    guiyin: "归隐",
    guiyin_info: "若你于弃牌阶段弃置了至少两张牌，你可以摸两张牌",
    shejie: "设界",
    shejie2: "设界",
    shejie_info: "每当你受到一次伤害，可以令伤害来源不能使用或打出其手牌，直到其下一回合开始",
    shejie2_info: "不能使用或打出手牌，直到下一回合开始",
    yinyue: "引月",
    yinyue_info: "每当有一名角色回复一次体力，你可以令其摸一张牌，若你的手牌数比其少，你也摸一张牌",
    mohua2: "魔化",
    mohua2_info: "锁定技，当你进入濒死状态时，你立即变身为撒旦，将体力回复至２，然后摸两张牌",
    liexin: "裂心",
    liexin_info: "每当你即将造成伤害，你可以弃置一张牌令伤害+1",
    swdxueyi: "血裔",
    swdxueyi_info: "锁定技，你摸牌阶段额外摸X张牌，X为你已损失的体力值",
    moyan: "血焰",
    moyan_info: "出牌阶段，你可以弃置X张红色手牌，然后对至多X名角色各造成一点火焰伤害，X为你已损失的体力值。每阶段限一次",
    aojian: "傲剑",
    aojian_info: "出牌阶段，你可以弃置X张手牌，然后对攻击范围内至多X名角色各造成一点伤害，X为你已损失的体力值。每阶段限一次",
    milesxiehun: "邪魂",
    milesxiehun_info: "锁定技，出牌阶段结束后，你令随机Ｘ名角色各弃置一张牌，Ｘ为你已损失的体力值且至少为1 ",
    liaochen: "撩尘",
    liaochen_info: "锁定技，出牌阶段结束后，所有角色需弃置一张牌",
    lianji: "连计",
    lianji_info: "出牌阶段限一次，你可以选择一张手牌并指定两名角色进行拼点，拼点赢的角色获得此牌，并对没赢的角色造成一点伤害",
    yinmo: "引魔",
    yinmo_info: "锁定技，当你对场上所有角色发动「连计」后，你立即变身为魔化宁珂，然后对所有其他角色造成一点雷电伤害",
    huanxing: "幻形",
    huanxing2: "幻形",
    huanxing_info: "回合开始阶段，你可以弃置一张处于并选择一名男性角色，获得其所有技能，直到你首次受到伤害",
    meihuo: "魅惑",
    meihuo_info: "每当你失去最后一张装备牌，你可以获得一名其他角色的一张牌，若此牌来自装备区，你立即装备之",

    touxi: "偷袭",
    touxi_info: "在其他角色的回合结束阶段，你可以进行一次判定，若结果为黑色，你对其造成一点雷电伤害并摸一张牌，且直到下一回合开始不能再次发动偷袭；若结果为红色，对方须弃置你的一张牌",
    minjing: "明镜",
    minjing_info: "锁定技，若你没有防具牌，你视为装备了光纱天衣",
    qimou: "奇谋",
    qimou_info: "每当你于回合外受到一次伤害，你可以摸一张牌，并立即使用之",
    mufeng: "沐风",
    mufeng_info: "当你成为一张指定了多个目标的锦囊牌的目标时，你可以取消之，并摸一张牌。",
    lexue: "乐学",
    lexue_info: "回合内，你随机获得制衡、集智、缔盟、驱虎中的一个技能；回合外，你随机获得遗计、急救、鬼道、反馈中的一个技能",
    mingfu: "冥缚",
    mingfu_info: "出牌阶段限一次，你可以将一张梅花牌当鬼幽结使用",
    chuanyue: "穿月",
    chuanyue_info: "出牌阶段限一次，你可以将两张手牌当决斗使用",

    miedao: "灭道",
    miedao1: "灭道",
    miedao2: "灭道",
    miedao_info: "锁定技，摸牌阶段，你额外摸X张牌；弃牌阶段，你至少须弃X张牌（不足则全弃），X为你已损失的体力值。",

    polang: "破浪",
    polang_info: "每当你造成一次伤害，可以弃置对方装备区内的所有牌。",
    jikong: "亟空",
    jikong2: "亟空",
    jikong_info: "每当你失去最后一手手牌，可以对一名角色造成一点雷电伤害；回合开始阶段，你可以指定一名角色视为对其使用一张雷杀",
    xiangu: "仙骨",
    xiangu_info: "锁定技，你的手牌上限不会因体力值的减少而减少。",
    yiesheng: "回雪",
    yiesheng_info: "出牌阶段，你可以弃置任意数量的黑色手牌，然后摸等量的牌。",
    huajian: "化剑",
    huajian_info: "出牌阶段结束时，你可以弃置一张牌，视为对一张角色使用一张杀",
    xuanyuan: "轩辕",
    xuanyuan_info: "锁定技，你无视轩辕剑的装备条件；失去轩辕剑时不流失体力",
    jilve: "极略",
    jilve2: "极略",
    jilve_info: "回合内，你可以观看牌堆顶的两张牌，然后使用其中的基本牌或锦囊牌",
    gongshen: "工神",
    gongshen_info: "任意一名其他角色使用一张基本牌或锦囊牌指定目标后，你可以弃置一张装备牌令其失效",

    liuhong: "流虹",
    liuhong_info: "每当你使用或打出一张杀，可以摸一张牌",
    poyue: "破月",
    poyue_info: "锁定技，你的黑杀无视距离，红色不计入回合内的出杀限制且不可闪避",
    mojian: "墨剑",
    mojian_info: "每当你使用杀并指定目标后，你可以令其摸一张牌，然后你回复一点体力",
    duanyue: "断月",
    duanyue_info: "出牌阶段限一次，你可以弃置一张装备牌，对一名其他角色造成一点伤害，并弃其所有手牌。若弃置的手牌数不少于3，你流失一点体力",
    fengmo: "封魔",
    fengmo_info: "出牌阶段限一次，你可以弃置场所有武器牌（至少两张），然后令一名未翻面的角色摸等量的牌并翻面",
    pozhou: "破咒",
    pozhou_bg: "破",
    pozhou2: "破咒",
    pozhou3: "破咒",
    pozhou3_bg: "咒",
    pozhou_info: "每当你受到一次伤害，你获得一枚破咒标记。在其他角色的回合开始阶段，你可以弃置一枚破咒标记令其所有非锁定技失效直到下一回合开始",
    xuanzhou: "玄咒",
    xuanzhou_info: "出牌阶段限一次，你可以将一张非延时锦囊牌当作任意一张延时锦囊，对任意一名角色使用（无视锦囊使用范围限制）",
    ningxian: "凝霰",
    ningxian_info: "每当你受到一次伤害，你可以弃置任意张黑色牌并选择等量其他角色对其各造成一点伤害",
    guanhu: "贯鹄",
    guanhu_info: "每当你使用杀造成伤害，你可以弃置对方一张牌",
    chuanyang: "穿杨",
    chuanyang_info: "每当你使用一张杀，若你不在目标的攻击范围，你可以令此杀不可闪避",
    fengming: "凤鸣",
    fengming_info: "出牌阶段限一次，你可以弃置一张装备牌，令一名角色恢复一点体力并摸一张牌",
    duanxing: "锻星",
    duanxing_info: "每当你装备一张装备牌，可以视为一名角色使用一张杀",
    wanjun: "万钧",
    wanjun_info: "你可以将一张装备牌当作南蛮入侵使用",
    dunxing: "遁形",
    dunxing_info: "锁定技，体力值比你多的角色无法在回合内对你使用卡牌",
    guiying: "鬼影",
    guiying_info: "你可以将一张黑色牌当偷梁换柱使用",
    shehun: "摄魂",
    shehun_info: "出牌阶段限一次，你可以弃置任意张花色不同的牌，另一名其他角色弃置等量的牌，若其弃置的牌中有牌的花色与你弃置的牌相同，你对其造成一点伤害",


    zhanlu: "沾露",
    luomu: "落木",
    jifeng: "魔影",
    liaoyuan: "燎原",
    chongsheng: "重生",
    huanhun: "唤魂",
    daixing: "代形",
    yishan: "异闪",
    yishan2: "异闪",
    swd_wuxie: "无邪",
    qingcheng: "倾城",
    xianjiang: "仙匠",
    xianjiang3: "仙匠",
    shengong: "神工",
    ningjian: "凝剑",
    ningjian1: "凝剑",
    ningjian2: "凝剑",
    taixu: "太虚",
    duoren: "夺刃",
    tanlin: "探麟",
    tanlin2: "探麟",
    pozhen: "破阵",
    yunchou: "运筹",
    tianshu: "天书",
    tianshu2: "天书",
    xingdian: "星点",
    luomei: "落梅",
    yulin: "玉鳞",
    funiao: "符鸟",
    lingbo: "凌波",
    xuehuang: "血凰",
    zhuyu: "朱羽",
    ningshuang: "凝霜",
    zaowu: "造物",
    // shouhua:'收化',
    xielv: "谐率",
    tianhuo: "天火",
    huanyin: "幻音",
    tianlun: "天轮",
    longyin: "龙吟",
    lanzhi: "兰芷",
    duanyi: "断意",
    miesheng: "灭生",
    guxing: "孤星",
    guxing1: "孤星",
    guxing2: "孤星",
    poxing: "破星",
    mohua: "魔化",
    miles_xueyi: "血裔",
    wuying: "无影",
    xiehun: "邪魂",
    xiehun1: "邪魂",
    xiehun2: "邪魂",
    xiehun3: "邪魂",
    jumo: "聚魔",
    duijue: "对决",
    yueren: "月刃",
    busi: "不死",
    xuying: "虚影",
    yinguo: "因果",
    guiyan: "鬼眼",
    guiyan2: "鬼眼",
    swd_xiuluo: "修罗",
    yunshen: "云身",
    yunshen2: "云身",
    suiyan: "碎岩",
    suiyan_info: "每当你造成一次伤害，可以弃置一张牌并弃置对方的全部装备牌",
    xianyin: "散结",
    qiaoxie: "巧械",
    xiaoji2: "巧械",
    xuanfeng2: "巧械",
    mailun: "脉轮",
    mailun31: "脉轮",
    mailun32: "脉轮",
    mailun41: "脉轮",
    mailun42: "脉轮",
    swdshelie: "涉猎",
    kunlunjing: "镜界",
    kunlunjing1: "镜界",
    kunlunjing2: "镜界",
    susheng: "苏生",
    shengshou: "圣手",
    huanjian: "幻箭",
    yuhuo: "浴火",
    huanjian_info: "你可以将一张黑色手牌当作毒箭使用",
    shengshou_info: "你可以将一张黑色手牌当作草药使用",
    susheng_info: "在任意一名角色即将死亡时，你可以弃置一张手牌防止其死亡，并将其体力回复至1",
    zhanlu_info: "出牌阶段，你可以弃置一张黑桃牌令至多３名角色各回复一点体力",
    kunlunjing_info: "回合开始前或当你受到一次伤害后，你可以令场上所有牌还原到你上一回合结束后的位置；若在回合开始前发动，你流失一点体力",
    swdshelie_info: "摸牌阶段，你可以放弃摸牌，改为从牌堆顶亮出五张牌，你获得不同花色的牌各一张，将其余的牌置入弃牌堆。",
    swd_xiuluo_info: "回合开始阶段，你可以弃一张手牌来弃置你判断区里的一张延时类锦囊（必须花色相同）",
    xianyin_info: "出牌阶段，你可以令所有判定区内有牌的角色弃置判定区内的牌，然后交给你一张手牌",
    qiaoxie_info: "每当你装备一张牌，可摸一张牌，每当你失去一张装备牌（不含替换），你可以弃置其他角色的一张牌",
    mailun_info: "回合开始阶段，你可以选择如下效果：一、减少一点体力并增加一点体力上限（不能超过6）；二、增加一点体力并减" +
      "少一点体力上限；三、令你即将造成和即将受到的首次伤害-1；四、令你即将造成和即将受到的首次伤害+1；五、少摸一张牌并令手牌上限+1" +
      "；六、多摸一张牌并令手牌上限-1；七、进攻距离+1，防御距离-1；八、进攻距离-1，防御距离+1",
    yunshen_info: "每当你打出一张闪，你可以令其他角色与你的距离+1；回合开始阶段，你将累计的防御距离清零，然后摸等量的牌",
    guiyan_info: "出牌阶段，你可以观看一名角色的手牌，并获得其中一张梅花牌，每阶段限一次。当你首次进入濒死状态时，你须回复一点体力并失去技能鬼眼",
    busi_info: "锁定技，你死亡后每次轮过你时你自动复活",
    xuying_info: "锁定技，每当你即将受到伤害，你防止此伤害，若你此时有手牌，你流失一点体力",
    yinguo_info: "除你之外的任意一名角色即将受到受到伤害时，若有伤害来源，你可以弃置一张牌将伤害来源和目标对调",
    yueren_info: "每当你使用一张杀，可以进行一次判定，若结果为黑色，你弃置目标一张牌，若结果为红色，你将此杀收回，每回合限发动一次",
    duijue_info: "限定技，出牌阶段，你可以指定一名角色与其单挑，直到一方死亡为止",
    wuying_info: "锁定技，你的杀和单体锦囊目标锁定为范围内的所有角色",
    xiehun_info: "锁定技，受到来自你伤害的角色进入混乱状态，行为不受控制，且会攻击队友，直到你的下一回合开始",
    jumo_info: "锁定技，回合结束阶段，你摸X-1张牌，X为未进入混乱状态的角色数与进入混乱状态的角色数之差（若为双将则改为X）",
    jifeng_info: "你的杀和单体锦囊可以额外指定任意个目标，若如此做，此卡牌有一定机率失效，指定的目标越多失效的概率越大",
    mohua_info: "锁定技，在身份局中，当你进入濒死状态时，你立即变身为撒旦，体力上限变为现存角色数（至少为4），并成为其他所有角色的共同敌人",
    miles_xueyi_info: "锁定技，你防止即将受到的伤害，然后流失一点体力",
    duanyi_info: "出牌阶段限一次，你可以弃置两张杀，对一名角色造成一点伤害，然后其翻面并摸X张牌，X为其已损失的体力值",
    guxing_info: "出牌阶段，你可以将最后至多X张手牌当杀使用，此杀无视距离且可以指定至多3个目标，每造成一次伤害，你摸一张牌，Ｘ为你已损失的体力值且至少为１。",
    tianlun_info: "任意一名角色的判定生效前，你可以弃置一张场上角色的判定牌替换之",
    longyin_info: "出牌阶段，你可以弃置任意张颜色相同且点数不同的牌，并获得逆时针座位距离与卡牌点数相同的角色区域内的一张牌。每阶段限一次",
    lanzhi_info: "每当你即将造成伤害，可以防止此伤害，然后摸两张牌。每回合限发动一次。",
    tianhuo_info: "出牌阶段，你可以令所有角色弃置其判定区域内的牌，并受到没有来源的等量火焰伤害，每阶段限一次",
    huanyin_info: "锁定技，每当你成为其他角色的卡牌的目标时，你进行一次判定，若为黑桃则取消之，若为红桃你摸一张牌",
    luomu_info: "锁定技，每当你造成伤害时，受伤害角色随机弃置一张牌",
    poxing_info: "锁定技，每当你即将造成伤害，若目标的体力值大于你，你令伤害+1",
    liaoyuan_info: "每当你使用一张杀结算完毕后，可以将一张与此牌花色相同的牌当杀对目标使用",
    yuhuo_info: "限定技，濒死阶段，你可以重置角色牌，减少一点体力上限，然后将体力回复至体力上限",
    yishan_info: "每当你受到一次伤害，你可以重新获得最近失去的两张牌",
    huanhun_info: "当一名角色进入濒死状态时，你可以弃置一张牌令其进行一次判定，若结果为红色，其回复一点体力",
    daixing_info: "回合结束阶段，你可以弃置至多X张牌，并抵挡等量伤害，效果在下一个回合结束阶段失效，X为现存角色数-1",
    swd_wuxie_info: "锁定技，你不能成为其他角色的延时锦囊的目标",
    qingcheng_info: "回合开始阶段，你可以进行判定，若为红色则可以继续判定，判定结束后将判定成功的牌收入手牌",
    xianjiang_info: "出牌阶段，你可以将一张装备牌永久转化为任意一张其它装备牌，一张牌在一个阶段只能转化一次",
    xianjiang3_info: "出牌阶段，若你装备区内没有牌，你可以弃置一张锦囊牌，并从牌堆中随机获得一张装备牌，若牌堆中没有装备牌，你摸一张牌，每阶段限一次",
    shengong_info: "每当你需要打出一张杀或闪时，你可以弃置一名角色装备区内的一张武器牌或防具牌，视为打出一张杀或闪，然后该角色摸一张牌，你弃一张牌",
    ningjian_info: "你可以将一张红色牌当闪、黑色牌当杀使用或打出",
    taixu_info: "限定技，你可以弃置你的所有牌（至少1张），并对一名体力值大于1为其他角色造成X点火焰伤害，X为你已损失的体力值且至少为1",
    duoren_info: "每当你闪避一张杀，你可以立即获得来源的武器牌",
    tanlin_info: "出牌阶段限一次，你可以与一名其他角色进行拼点，若你赢，你获得双方拼点牌、对该角色使用卡牌无视距离且可以额外使用一张杀直到回合结束，若你没赢，你受到该角色的一点伤害。",
    pozhen_info: "每当你受到一次伤害，若你的手牌数大于伤害来源，你可以弃置X张手牌对其造成一点伤害；若你的手牌数小于伤害来源，你可以弃置其X张手牌。X为你与伤害来源的手牌数之差。",
    yunchou_info: "出牌阶段限一次，你可以弃置任意张手牌，并弃置一张其他角色的手牌，你弃置的手牌中每有一张与此牌的颜色相同，你摸一张牌，否则对方摸一张牌",
    tianshu_info: "回合开始阶段，你可以获得场上一名存活角色的一项技能；出牌阶段，你可以弃置一张锦囊牌，然后更换一项技能",
    luomei_info: "每当你使用或打出一张梅花花色的牌，你可以摸一张牌",
    xingdian_info: "出牌阶段限一次，你可以弃置一张手牌，然后指定至多两名角色令其各弃置一张牌",
    yulin_info: "每当你即将受到伤害，你可以弃置一张装备牌抵消此伤害",
    funiao_info: "出牌阶段，你可以交给一名角色一张手牌，然后观看其手牌，每个阶段对一名角色只能发动一次",
    zhexian_info: "每当你使用或打出一张闪，你可以摸两张牌",
    lingbo_info: "每当你使用或打出一张闪，你可以摸两张牌",
    xuehuang_info: "出牌阶段限一次，你可以弃置一张红色手牌令距离你一以内的所有角色受到一点火焰伤害",
    zhuyu_info: "每当有横置的角色即将受到非火焰伤害，你可以弃置一张红色牌使其额外受到一点火焰伤害",
    ningshuang_info: "每当你成为黑色牌的目标，你可以弃置一张黑色牌将其横置，并摸一张牌，若其已经模置则将其翻面",
    zaowu_info: "出牌阶段，你可以弃置三张不同类型的牌，创造任意两张牌并获得之",
    xielv_info: "弃牌阶段结束后，若你的所有手牌（至少两张）颜色均相同，你可以展示所有手牌，然后选择一项：1、回复一点体力；2、弃置场上所有与你手牌颜色不同的牌"
  }
};
